import{_ as e,o as a,c as l,V as i}from"./chunks/framework.ff44d2fd.js";const f=JSON.parse('{"title":"vue2-principle-learning","description":"","frontmatter":{},"headers":[],"relativePath":"vue2原理剖析/README.md","filePath":"vue2原理剖析/README.md","lastUpdated":1712818751000}'),t={name:"vue2原理剖析/README.md"},r=i('<h1 id="vue2-principle-learning" tabindex="-1">vue2-principle-learning <a class="header-anchor" href="#vue2-principle-learning" aria-label="Permalink to &quot;vue2-principle-learning&quot;">​</a></h1><p>Vue2 内部运行机制，源码分析</p><p>Vue2 官方文档：<a href="https://v2.cn.vuejs.org/v2/guide/index.html" target="_blank" rel="noreferrer">https://v2.cn.vuejs.org/v2/guide/index.html</a></p><h2 id="源码学习" tabindex="-1">源码学习 <a class="header-anchor" href="#源码学习" aria-label="Permalink to &quot;源码学习&quot;">​</a></h2><blockquote><p>灵魂提问：学习 Vue 源码，到底是为了学习 Vue 的什么？</p></blockquote><p>我认为主要学习以下几点：</p><p>核心模块：</p><ul><li><a href="./响应式系统/readme.html">响应式原理</a>：Vue.js 的响应式系统使得数据和视图之间保持同步。</li><li>编译原理：Vue.js 使用基于模板的方式来组织用户界面，编译器负责将模板转换为可执行的渲染函数。</li><li>虚拟 DOM：Vue.js 使用虚拟 DOM 来追踪界面的状态变化，以提高渲染效率</li><li>渲染原理：渲染器负责将虚拟 DOM 渲染到实际的浏览器 DOM 中</li><li>组件系统</li></ul><p>辅助模块：</p><ul><li>事件机制</li><li>生命周期</li></ul><p>周边模块：</p><ul><li>Vuex 原理</li><li>VueRouter 原理</li></ul><h2 id="模板渲染" tabindex="-1">模板渲染 <a class="header-anchor" href="#模板渲染" aria-label="Permalink to &quot;模板渲染&quot;">​</a></h2><ul><li><a href="./模版渲染/template如何转换成渲染函数的？.html">template 生成 render function</a></li><li><a href="./模版渲染/渲染函数如何转换成VNode节点？.html">render function 生成 VNode</a></li><li><a href="./模版渲染/VNode的Patch过程.html">新旧 VNode 通过 Diff 算法更新视图</a></li></ul><h2 id="异步更新策略" tabindex="-1">异步更新策略 <a class="header-anchor" href="#异步更新策略" aria-label="Permalink to &quot;异步更新策略&quot;">​</a></h2><ul><li><a href="./异步更新策略和nextTick原理.html">异步更新策略和 nextTick 原理</a></li></ul>',16),n=[r];function o(u,h,c,p,d,s){return a(),l("div",null,n)}const m=e(t,[["render",o]]);export{f as __pageData,m as default};
