import{_ as s,o as n,c as a,V as p}from"./chunks/framework.ff44d2fd.js";const B=JSON.parse('{"title":"Vue 事件机制","description":"","frontmatter":{},"headers":[],"relativePath":"vue2原理剖析/Vue事件机制/Vue事件机制.md","filePath":"vue2原理剖析/Vue事件机制/Vue事件机制.md","lastUpdated":1720490741000}'),l={name:"vue2原理剖析/Vue事件机制/Vue事件机制.md"},o=p(`<h1 id="vue-事件机制" tabindex="-1">Vue 事件机制 <a class="header-anchor" href="#vue-事件机制" aria-label="Permalink to &quot;Vue 事件机制&quot;">​</a></h1><p><a href="https://github.com/answershuto/learnVue/blob/master/docs/Vue%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6.MarkDown" target="_blank" rel="noreferrer">参考文档</a></p><h2 id="补充" tabindex="-1">补充 <a class="header-anchor" href="#补充" aria-label="Permalink to &quot;补充&quot;">​</a></h2><h3 id="on-fn-fn-的作用是什么" tabindex="-1">on.fn = fn 的作用是什么？ <a class="header-anchor" href="#on-fn-fn-的作用是什么" aria-label="Permalink to &quot;on.fn = fn 的作用是什么？&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#79B8FF;">Vue</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">$once</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">fn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Function</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">vm</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/*在第一次执行的时候将该事件销毁*/</span></span>
<span class="line"><span style="color:#E1E4E8;">    vm.</span><span style="color:#B392F0;">$off</span><span style="color:#E1E4E8;">(event, on);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/*执行注册的方法*/</span></span>
<span class="line"><span style="color:#E1E4E8;">    fn.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(vm, </span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  on.fn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fn;</span></span>
<span class="line"><span style="color:#E1E4E8;">  vm.</span><span style="color:#B392F0;">$on</span><span style="color:#E1E4E8;">(event, on);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> vm;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><p>on.fn = fn 这行代码的作用是将传入的回调函数 fn 保存到 on 函数的 fn 属性上。</p><p>这样做的目的是为了在 on 函数内部可以访问到原始的回调函数 fn。因为当使用 vm.$on(event, on) 注册事件监听时,会传入 on 函数作为回调,而不是原始的 fn。</p><p>在 on 函数内部,我们在执行回调时需要调用原始的 fn 函数,所以需要将其保存到 on 函数的属性上,以便内部可以访问到。</p><p>此外,之所以需要保存它,是因为在执行 on 函数时,this 指向将会改变,导致无法通过 this.fn 或类似的方式获取到原始的回调函数。</p><p>所以综上,on.fn = fn 这行代码使得 on 函数内部可以访问到外部传入的原始回调 fn,从而在适当的时机执行它。</p><h3 id="解释下-emit-方法的含义" tabindex="-1">解释下$emit 方法的含义 <a class="header-anchor" href="#解释下-emit-方法的含义" aria-label="Permalink to &quot;解释下$emit 方法的含义&quot;">​</a></h3><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#79B8FF;">Vue</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">$emit</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">event</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">vm</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (p<wbr>rocess.env.</span><span style="color:#79B8FF;">NODE_ENV</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;production&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">lowerCaseEvent</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> event.</span><span style="color:#B392F0;">toLowerCase</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (lowerCaseEvent </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> event </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> vm._events[lowerCaseEvent]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">tip</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#9ECBFF;">\`Event &quot;\${</span><span style="color:#E1E4E8;">lowerCaseEvent</span><span style="color:#9ECBFF;">}&quot; is emitted in component \`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#9ECBFF;">\`\${</span><span style="color:#B392F0;">formatComponentName</span><span style="color:#9ECBFF;">(</span><span style="color:#E1E4E8;">vm</span><span style="color:#9ECBFF;">)</span><span style="color:#9ECBFF;">} but the handler is registered for &quot;\${</span><span style="color:#E1E4E8;">event</span><span style="color:#9ECBFF;">}&quot;. \`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#9ECBFF;">\`Note that HTML attributes are case-insensitive and you cannot use \`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#9ECBFF;">\`v-on to listen to camelCase events when using in-DOM templates. \`</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#9ECBFF;">\`You should probably use &quot;\${</span><span style="color:#B392F0;">hyphenate</span><span style="color:#9ECBFF;">(</span><span style="color:#E1E4E8;">event</span><span style="color:#9ECBFF;">)</span><span style="color:#9ECBFF;">}&quot; instead of &quot;\${</span><span style="color:#E1E4E8;">event</span><span style="color:#9ECBFF;">}&quot;.\`</span></span>
<span class="line"><span style="color:#E1E4E8;">      );</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> cbs </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> vm._events[event];</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cbs) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/*将类数组的对象转换成数组*/</span></span>
<span class="line"><span style="color:#E1E4E8;">    cbs </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cbs.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">toArray</span><span style="color:#E1E4E8;">(cbs) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> cbs;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">args</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">toArray</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">arguments</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/*遍历执行*/</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, l </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cbs.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> l; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      cbs[i].</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(vm, args);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> vm;</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><p>这段代码是 Vue.$emit 的实现,用于触发组件上的事件。</p><p>主要逻辑如下:</p><ol><li><p>在非生产环境下,检查事件名称的大小写是否正确,以发出警告。</p></li><li><p>从组件的_events 对象中获取对应事件名称的回调函数数组 cbs。</p></li><li><p>如果 cbs 存在,则将其转换为数组。因为_events 中存储的回调可能是数组,也可能是单个函数。</p></li><li><p>获取额外的参数 args。</p></li><li><p>遍历 cbs 数组,依次调用每个回调函数,并传入事件参数 args。</p></li><li><p>返回组件实例本身。</p></li></ol><p>其中关键点是第 5 步,遍历回调函数并传入参数,这实现了事件的触发并传递参数。</p><p>而回调函数数组 cbs 来源于组件通过$on 注册的事件监听器。这使得组件可以灵活地监听并响应自身事件。</p><p>所以这段代码连接起了事件的触发和监听,是 Vue 事件机制的核心之一。</p>`,18),e=[o];function t(E,c,r,y,F,i){return n(),a("div",null,e)}const f=s(l,[["render",t]]);export{B as __pageData,f as default};
