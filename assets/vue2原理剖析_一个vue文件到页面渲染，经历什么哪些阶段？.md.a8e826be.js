import{_ as s,o as a,c as n,V as l}from"./chunks/framework.ff44d2fd.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"vue2原理剖析/一个vue文件到页面渲染，经历什么哪些阶段？.md","filePath":"vue2原理剖析/一个vue文件到页面渲染，经历什么哪些阶段？.md","lastUpdated":1720490741000}'),p={name:"vue2原理剖析/一个vue文件到页面渲染，经历什么哪些阶段？.md"},o=l(`<h2 id="从一个-vue-文件-到渲染出界面-经历了哪些重要的步骤" tabindex="-1">从一个 vue 文件，到渲染出界面，经历了哪些重要的步骤？ <a class="header-anchor" href="#从一个-vue-文件-到渲染出界面-经历了哪些重要的步骤" aria-label="Permalink to &quot;从一个 vue 文件，到渲染出界面，经历了哪些重要的步骤？&quot;">​</a></h2><p>从一个 Vue 文件到渲染出界面的过程可以分为多个关键步骤。每个步骤都有具体的实现机制。以下是详细的步骤解析：</p><h3 id="_1-编译阶段" tabindex="-1">1. 编译阶段 <a class="header-anchor" href="#_1-编译阶段" aria-label="Permalink to &quot;1. 编译阶段&quot;">​</a></h3><h4 id="a-解析模板-template-parsing" tabindex="-1">a. 解析模板 (Template Parsing) <a class="header-anchor" href="#a-解析模板-template-parsing" aria-label="Permalink to &quot;a. 解析模板 (Template Parsing)&quot;">​</a></h4><ul><li><strong>解析 Vue 文件</strong>：一个 <code>.vue</code> 文件包含模板、脚本和样式部分。Vue 编译器首先将这个文件解析成各个部分。</li><li><strong>解析模板字符串</strong>：使用模板解析器 (<code>parse</code> 函数)，将模板字符串解析成抽象语法树 (AST)。</li></ul><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">&lt;!-- Example Vue File --&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;app&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;{{ message }}&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">data</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        message: </span><span style="color:#9ECBFF;">&#39;Hello, Vue!&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      };</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><h4 id="b-优化-ast-optimize-ast" tabindex="-1">b. 优化 AST (Optimize AST) <a class="header-anchor" href="#b-优化-ast-optimize-ast" aria-label="Permalink to &quot;b. 优化 AST (Optimize AST)&quot;">​</a></h4><ul><li><strong>静态节点标记</strong>：优化过程会遍历 AST，标记静态节点和静态子树。这样可以在更新过程中跳过这些静态内容，提高渲染性能。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// Example AST Node</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">type</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// Element type</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">tag</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;div&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">attrsList</span><span style="color:#E1E4E8;">: [{ name: </span><span style="color:#9ECBFF;">&#39;id&#39;</span><span style="color:#E1E4E8;">, value: </span><span style="color:#9ECBFF;">&#39;app&#39;</span><span style="color:#E1E4E8;"> }],</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">attrsMap</span><span style="color:#E1E4E8;">: { </span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&#39;app&#39;</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">children</span><span style="color:#E1E4E8;">: [</span></span>
<span class="line"><span style="color:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#E1E4E8;">      type: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      tag: </span><span style="color:#9ECBFF;">&#39;p&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      children: [</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span></span>
<span class="line"><span style="color:#E1E4E8;">          type: </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// Expression type</span></span>
<span class="line"><span style="color:#E1E4E8;">          expression: </span><span style="color:#9ECBFF;">&#39;_s(message)&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">          text: </span><span style="color:#9ECBFF;">&#39;{{ message }}&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      ]</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  ]</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h4 id="c-生成代码-code-generation" tabindex="-1">c. 生成代码 (Code Generation) <a class="header-anchor" href="#c-生成代码-code-generation" aria-label="Permalink to &quot;c. 生成代码 (Code Generation)&quot;">​</a></h4><ul><li><strong>生成渲染函数代码</strong>：将优化后的 AST 转换成渲染函数代码字符串 (<code>generate</code> 函数)。这个过程会遍历 AST 并生成相应的代码。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// Generated Render Function Code</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">with</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">_c</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;div&#39;</span><span style="color:#E1E4E8;">, { attrs: { id: </span><span style="color:#9ECBFF;">&#39;app&#39;</span><span style="color:#E1E4E8;"> } }, [</span><span style="color:#B392F0;">_c</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;p&#39;</span><span style="color:#E1E4E8;">, [</span><span style="color:#B392F0;">_v</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">_s</span><span style="color:#E1E4E8;">(message))])]);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-运行时阶段" tabindex="-1">2. 运行时阶段 <a class="header-anchor" href="#_2-运行时阶段" aria-label="Permalink to &quot;2. 运行时阶段&quot;">​</a></h3><h4 id="a-初始化组件-component-initialization" tabindex="-1">a. 初始化组件 (Component Initialization) <a class="header-anchor" href="#a-初始化组件-component-initialization" aria-label="Permalink to &quot;a. 初始化组件 (Component Initialization)&quot;">​</a></h4><ul><li><strong>创建组件实例</strong>：使用组件构造函数 (<code>Vue.extend</code>) 创建组件实例。</li><li><strong>初始化数据</strong>：在组件实例化过程中，Vue 会初始化数据 (<code>data</code>)，将数据转化为响应式对象。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// Component Initialization</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">vm</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Vue</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">data</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      message: </span><span style="color:#9ECBFF;">&#39;Hello, Vue!&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  render,</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h4 id="b-渲染函数执行-render-function-execution" tabindex="-1">b. 渲染函数执行 (Render Function Execution) <a class="header-anchor" href="#b-渲染函数执行-render-function-execution" aria-label="Permalink to &quot;b. 渲染函数执行 (Render Function Execution)&quot;">​</a></h4><ul><li><strong>生成虚拟 DOM (VNode)</strong>：调用渲染函数生成虚拟 DOM 树。</li><li><strong>创建渲染 Watcher</strong>：创建一个渲染 Watcher，用于追踪渲染函数中响应式数据的依赖。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// Render Function Execution</span></span>
<span class="line"><span style="color:#E1E4E8;">vm.</span><span style="color:#B392F0;">_render</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.$options.render.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre></div><h4 id="c-虚拟-dom-映射到真实-dom-vnode-to-dom-mapping" tabindex="-1">c. 虚拟 DOM 映射到真实 DOM (VNode to DOM Mapping) <a class="header-anchor" href="#c-虚拟-dom-映射到真实-dom-vnode-to-dom-mapping" aria-label="Permalink to &quot;c. 虚拟 DOM 映射到真实 DOM (VNode to DOM Mapping)&quot;">​</a></h4><ul><li><strong>创建真实 DOM</strong>：将虚拟 DOM 树转换成真实 DOM 元素，并插入到页面中。</li><li><strong>调用 <code>patch</code> 函数</strong>：<code>patch</code> 函数用于比较虚拟 DOM 树的变化，并进行相应的 DOM 更新。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// Patch Function Example</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">patch</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">oldVNode</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">vnode</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// Create real DOM elements from VNode</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">el</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createElm</span><span style="color:#E1E4E8;">(vnode);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// Replace old DOM elements with new ones</span></span>
<span class="line"><span style="color:#E1E4E8;">  oldVNode.elm.parentNode.</span><span style="color:#B392F0;">replaceChild</span><span style="color:#E1E4E8;">(el, oldVNode.elm);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3-更新阶段" tabindex="-1">3. 更新阶段 <a class="header-anchor" href="#_3-更新阶段" aria-label="Permalink to &quot;3. 更新阶段&quot;">​</a></h3><h4 id="a-响应式系统-reactivity-system" tabindex="-1">a. 响应式系统 (Reactivity System) <a class="header-anchor" href="#a-响应式系统-reactivity-system" aria-label="Permalink to &quot;a. 响应式系统 (Reactivity System)&quot;">​</a></h4><ul><li><strong>依赖收集</strong>：在渲染过程中，当访问响应式数据时，会触发 getter，记录依赖 (Watcher)。</li><li><strong>数据更新</strong>：当响应式数据发生变化时，触发 setter，通知依赖更新。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// Reactive Data Example</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">data</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  message: </span><span style="color:#9ECBFF;">&#39;Hello, Vue!&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">defineProperty</span><span style="color:#E1E4E8;">(data, </span><span style="color:#9ECBFF;">&#39;message&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Collect dependency</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newVal</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Notify watchers</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><h4 id="b-组件重新渲染-component-re-rendering" tabindex="-1">b. 组件重新渲染 (Component Re-rendering) <a class="header-anchor" href="#b-组件重新渲染-component-re-rendering" aria-label="Permalink to &quot;b. 组件重新渲染 (Component Re-rendering)&quot;">​</a></h4><ul><li><strong>重新计算虚拟 DOM</strong>：当数据变化时，渲染 Watcher 会重新执行渲染函数，生成新的虚拟 DOM 树。</li><li><strong>比较新旧虚拟 DOM</strong>：<code>patch</code> 函数比较新旧虚拟 DOM 树的差异，进行最小化的 DOM 更新。</li></ul><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// Update Example</span></span>
<span class="line"><span style="color:#E1E4E8;">vm.message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;Hello, World!&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// Re-render and patch the DOM</span></span>
<span class="line"><span style="color:#E1E4E8;">vm.</span><span style="color:#B392F0;">_update</span><span style="color:#E1E4E8;">(vm.</span><span style="color:#B392F0;">_render</span><span style="color:#E1E4E8;">());</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>从一个 Vue 文件到渲染出界面的全过程如下：</p><ol><li><p><strong>编译阶段</strong>：</p><ul><li>解析模板为 AST。</li><li>优化 AST，标记静态节点。</li><li>生成渲染函数代码。</li></ul></li><li><p><strong>运行时阶段</strong>：</p><ul><li>初始化组件实例，创建响应式数据。</li><li>执行渲染函数，生成虚拟 DOM 树。</li><li>虚拟 DOM 树映射到真实 DOM，并插入页面。</li></ul></li><li><p><strong>更新阶段</strong>：</p><ul><li>响应式系统追踪数据依赖和变化。</li><li>数据更新时，重新计算虚拟 DOM 树。</li><li>比较新旧虚拟 DOM 树，进行最小化 DOM 更新。</li></ul></li></ol><p>通过这些步骤，Vue 实现了高效的模板编译和数据驱动的视图更新。</p>`,33),e=[o];function t(c,r,E,i,y,d){return a(),n("div",null,e)}const F=s(p,[["render",t]]);export{h as __pageData,F as default};
