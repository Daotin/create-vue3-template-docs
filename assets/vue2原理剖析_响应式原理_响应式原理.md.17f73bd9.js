import{_ as a,o as e,c as l,S as p}from"./chunks/framework.d5a27ec8.js";const n="/fe-series-notes/assets/2023-10-12-14-53-03.43a53ce6.png",y=JSON.parse('{"title":"响应式系统","description":"","frontmatter":{},"headers":[],"relativePath":"vue2原理剖析/响应式原理/响应式原理.md","filePath":"vue2原理剖析/响应式原理/响应式原理.md","lastUpdated":1724231299000}'),o={name:"vue2原理剖析/响应式原理/响应式原理.md"};function t(c,s,r,i,E,d){return e(),l("div",null,s[0]||(s[0]=[p('<h1 id="响应式系统" tabindex="-1">响应式系统 <a class="header-anchor" href="#响应式系统" aria-label="Permalink to &quot;响应式系统&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">面试官：简要介绍下 vue2 的响应式原理。</p><ol><li>Vue 2 的响应式系统核心是通过 <code>Object.defineProperty()</code> 来劫持数据对象的属性，将数据对象的属性转换为 getter 和 setter。</li><li>当组件渲染时，会触发 getter，此时 Vue 会将正在渲染的组件作为依赖收集到一个依赖收集器（Dep）中。</li><li>当数据发生变化时，setter 会被调用，通知之前收集的依赖进行更新。</li></ol></div><p><img src="'+n+`" alt=""></p><h2 id="vue2-响应式简易实现原理" tabindex="-1">vue2 响应式简易实现原理 <a class="header-anchor" href="#vue2-响应式简易实现原理" aria-label="Permalink to &quot;vue2 响应式简易实现原理&quot;">​</a></h2><p>下面是一个简化的代码示例，演示 vue2 的响应式工作原理：<a href="/fe-series-notes/observer/observer1.js">参看代码 observer1.js</a></p><p>代码解释:</p><ol><li><p><code>Vue</code> 类: 这是我们的主类,模拟了 Vue 实例。它在构造函数中初始化数据,并调用 <code>observe</code> 方法来使数据变为响应式。</p></li><li><p><code>observe</code> 方法: 遍历数据对象的所有属性,对每个属性调用 <code>defineReactive</code> 方法。</p></li><li><p><code>defineReactive</code> 方法: 这是实现响应式的核心。它使用 <code>Object.defineProperty</code> 来重新定义属性的 getter 和 setter。</p><ul><li>getter: 当属性被访问时,如果有正在收集依赖的目标(<code>Dep.target</code>),就将其添加到依赖列表中。</li><li>setter: 当属性被修改时,通知所有依赖进行更新。</li></ul></li><li><p><code>Dep</code> 类: 依赖收集器,管理与某个响应式属性相关的所有观察者(Watcher)。</p></li><li><p><code>Watcher</code> 类: 观察者,负责在数据变化时执行更新操作。</p></li><li><p><code>compile</code> 方法: 简化版的模板编译,它查找模板中的 <code>{ { } }</code> 插值,并为每个插值创建一个 Watcher。</p></li></ol><h2 id="组件渲染-watcher" tabindex="-1">组件渲染 Watcher <a class="header-anchor" href="#组件渲染-watcher" aria-label="Permalink to &quot;组件渲染 Watcher&quot;">​</a></h2><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>上面的代码示例中，是对每个属性都会创建一个新的 Watcher。</p><p>在 Vue 2 的实际实现中，对于普通的数据属性（如您例子中的 name 和 age），不会为每次使用都创建一个 Watcher。相反，每个组件只有一个渲染 Watcher，负责整个组件模板的渲染。这个渲染 Watcher 会被添加到模板中使用的所有响应式属性的 Dep 中，但每个 Dep 只会包含这个渲染 Watcher 一次。</p></div><p>所以，Vue 2 实际的实现逻辑：</p><ol><li><p>对于每个组件，Vue 只创建一个渲染 Watcher。这个 Watcher 负责该组件的整个模板的渲染。</p></li><li><p>依赖收集过程：在渲染过程中，每当访问到一个响应式属性（例如在模板中使用 name），该属性的 getter 会被触发。在 getter 中，当前的渲染 Watcher 会被添加到该属性对应的 Dep 中。</p></li><li><p>多次使用同一属性：即使一个属性在模板中被使用多次，它的 getter 只会将同一个渲染 Watcher 添加到 Dep 中一次。因为 Dep 使用一个集合（Set）来存储 Watcher，确保不会重复添加同一个 Watcher。</p></li><li><p>更新过程：当 name 或 age 发生变化时，它们会通知各自的 Dep。Dep 然后会通知其中的渲染 Watcher。这个渲染 Watcher 会触发组件的重新渲染，更新所有使用了这些属性的地方。</p></li><li><p>优化：Vue 2 使用虚拟 DOM 来优化更新过程。即使一个属性在模板中使用多次，也只需要一次比对就能确定所有需要更新的地方。</p></li></ol><div class="info custom-block"><p class="custom-block-title">INFO</p><p>问：我大概明白了，就是对于组件只有一个 Watcher，但是不同的属性的 Dep，都会只添加一次这个 Watcher 是吧？假设 name 和 age 都变了，那么会执行两个 Dep 中的 watcher，因为 watcher 是同一个，所以会执行两次吗？</p></div><p>您说得对，对于一个组件确实只有一个渲染 Watcher，而且不同属性的 Dep 中都会添加这个相同的 Watcher（但每个 Dep 中只添加一次）。关于多个属性变化时 Watcher 的执行，情况是这样的：</p><ol><li><p>Watcher 的去重机制：Vue 2 在 Watcher 中实现了一个智能的去重机制。当一个 Watcher 被触发时，它不会立即执行更新，而是被标记为&quot;脏&quot;（dirty）。Vue 使用一个队列来收集所有&quot;脏&quot;的 Watcher，并在下一个&quot;tick&quot;中统一更新。</p></li><li><p>多个属性变化的情况：假设 name 和 age 都变化了。两个属性的 Dep 都会通知它们共同的渲染 Watcher。但是，这个 Watcher 只会被添加到更新队列中一次。</p></li><li><p>更新过程：在下一个&quot;tick&quot;，Vue 会遍历更新队列。渲染 Watcher 只会执行一次更新操作，这次更新会处理所有变化的数据。这意味着组件只会重新渲染一次，而不是每个变化的属性都触发一次渲染。</p></li></ol><p>这种机制大大提高了 Vue 的性能，避免了不必要的重复渲染。</p><p>具体代码见：<a href="/fe-series-notes/observer/observer2.js">observer2.js</a></p><p>代码解释：</p><ol><li><p>渲染 Watcher：</p><ul><li>在 Vue 构造函数中，我们创建了一个渲染 Watcher（<code>this.$watcher</code>）。</li><li>这个 Watcher 负责整个组件的渲染，对应 Vue 2 中的组件级 Watcher。</li></ul></li><li><p>Dep 类的改进：</p><ul><li>使用 Set 来存储订阅者，确保不会重复添加同一个 Watcher。</li></ul></li><li><p>Watcher 类的改进：</p><ul><li>添加了<code>deps</code>和<code>newDeps</code>来管理依赖关系。</li><li>实现了<code>addDep</code>和<code>cleanupDeps</code>方法来处理依赖的添加和清理。</li><li><code>update</code>方法不再直接触发更新，而是将自身加入更新队列。</li></ul></li><li><p>异步更新队列：</p><ul><li>实现了<code>queueWatcher</code>函数，用于将 Watcher 加入队列。</li><li>使用 Promise 来模拟 Vue 2 中的 nextTick 机制。</li><li><code>flushQueue</code>函数负责在下一个事件循环中执行所有队列中的 Watcher 更新。</li></ul></li><li><p>渲染函数：</p><ul><li>简化的<code>render</code>方法模拟了模板的渲染过程。</li></ul></li></ol><h2 id="单个属性-watcher" tabindex="-1">单个属性 watcher <a class="header-anchor" href="#单个属性-watcher" aria-label="Permalink to &quot;单个属性 watcher&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p>还有一个小问题，在 vue2 具体的实现中，是否还存在单个元素的 watcher 呢？</p></div><p>在 Vue 2 的实际实现中，除了组件级别的渲染 Watcher，还存在其他类型的 Watcher，包括您提到的单个元素的 Watcher。让我详细解释一下：</p><ol><li><p>渲染 Watcher（Render Watcher）：</p><ul><li>这是我们之前讨论的主要类型，每个组件有一个。</li><li>负责整个组件模板的渲染。</li></ul></li><li><p>计算属性 Watcher（Computed Watcher）：</p><ul><li>每个计算属性都有自己的 Watcher。</li><li>用于懒计算和缓存计算属性的值。</li></ul></li><li><p>侦听器 Watcher（User Watcher）：</p><ul><li>由用户通过 <code>watch</code> 选项或 <code>$watch</code> 方法创建。</li><li>用于观察特定数据变化并执行自定义逻辑。</li></ul></li><li><p>指令 Watcher：</p><ul><li>某些指令（如 <code>v-for</code>、<code>v-if</code> 等）可能会创建自己的 Watcher 来处理局部的更新逻辑。</li></ul></li><li><p>单个元素 Watcher：</p><ul><li>在某些特殊情况下，Vue 2 确实会为单个元素创建 Watcher。</li><li>这通常发生在使用某些高级特性时，比如： a. <code>v-for</code> 指令中使用 <code>track-by</code>。 b. 使用 <code>v-if</code> / <code>v-else</code> / <code>v-else-if</code> 进行条件渲染。 c. 动态组件（使用 <code>&lt;component :is=&quot;...&quot;&gt;</code>）。</li></ul></li></ol><p>这些单个元素的 Watcher 主要用于优化性能，允许 Vue 在某些情况下进行更细粒度的更新，而不是重新渲染整个组件。</p><p>举个例子，考虑以下模板：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-for</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;item in items&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">:key</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;item.id&quot;</span><span style="color:#E1E4E8;">&gt;{{ item.name }}&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>在这种情况下，Vue 可能会为每个列表项创建一个 Watcher，以便在 items 数组发生变化时能够高效地更新 DOM，而不是重新渲染整个列表。</p><p>然而，需要注意的是：</p><ol><li>这些细粒度的 Watcher 是 Vue 内部优化的结果，并不直接暴露给开发者。</li><li>Vue 会根据具体情况决定是否创建这些额外的 Watcher，以平衡性能和内存使用。</li><li>在大多数情况下，组件级别的渲染 Watcher 已经足够高效，Vue 不需要创建额外的单元素 Watcher。</li></ol><p>总的来说，虽然 Vue 2 确实在某些情况下使用单个元素的 Watcher，但这是作为一种内部优化机制，而不是响应式系统的主要部分。</p><p>在日常开发中，我们主要关注的是组件级别的响应式和更新机制。只有在需要进行高级性能优化时，才可能需要考虑这些更细节的实现。</p><h2 id="代理" tabindex="-1">代理 <a class="header-anchor" href="#代理" aria-label="Permalink to &quot;代理&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p>现在我们的代码是通过 app.$data.name 进行更新数据的，但是在 vue 实际开发中，我们通常使用 this.name 直接修改，请问 vue 是如何做到的？</p></div><ol><li>数据代理</li></ol><p>Vue 实现这一特性的主要机制是&quot;数据代理&quot;。在 Vue 实例创建过程中，它会对 data 对象的属性进行代理。这意味着 Vue 会在实例上创建与 data 中属性同名的属性，并将这些属性的 getter 和 setter 代理到<code>$data</code>上对应的属性。</p><ol start="2"><li>实现方式</li></ol><p>Vue 使用<code>Object.defineProperty</code>（在 Vue 3 中是 Proxy）来实现这种代理。大致过程如下：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Vue</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">options</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.$data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> options.data;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.$data);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">proxy</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.$data); </span><span style="color:#6A737D;">// 新增：代理数据</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ... 其他初始化代码 ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ... 保持原有的观察者逻辑 ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">proxy</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object.</span><span style="color:#B392F0;">keys</span><span style="color:#E1E4E8;">(data).</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      Object.</span><span style="color:#B392F0;">defineProperty</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, key, {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.$data[key];</span></span>
<span class="line"><span style="color:#E1E4E8;">        },</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.$data[key] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newValue;</span></span>
<span class="line"><span style="color:#E1E4E8;">        },</span></span>
<span class="line"><span style="color:#E1E4E8;">      });</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ... 其他方法 ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 使用示例</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">app</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Vue</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">  el: </span><span style="color:#9ECBFF;">&#39;#app&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  data: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    name: </span><span style="color:#9ECBFF;">&#39;Vue&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    count: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(app.name); </span><span style="color:#6A737D;">// 输出: &#39;Vue&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">app.name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;Vue 2&#39;</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 这会触发响应式更新</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(app.$data.name); </span><span style="color:#6A737D;">// 输出: &#39;Vue 2&#39;</span></span></code></pre></div><p>这样，当你访问或修改<code>app.name</code>时，实际上是在访问或修改<code>app.$data.name</code>。</p><h2 id="vue-何时完成收集依赖的" tabindex="-1">vue 何时完成收集依赖的 <a class="header-anchor" href="#vue-何时完成收集依赖的" aria-label="Permalink to &quot;vue 何时完成收集依赖的&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p>在上面代码例子中，当我把响应式数据写到 template 中时，是第一次渲染实际数据的时候完成依赖收集的吗？vue 实际上也是在第一次渲染真实数据的时候收集依赖的吗？</p></div><ol><li>我们的简化实现：</li></ol><p>在我们的简化代码中，确实是在第一次渲染实际数据时完成依赖收集。这发生在<code>render</code>方法被调用时：</p><ul><li>当我们访问数据（如<code>data[key]</code>）来替换模板中的插值表达式时，会触发属性的 getter。</li><li>在 getter 中，如果存在<code>Dep.target</code>（即当前正在评估的 Watcher），就会将这个 Watcher 添加到属性的依赖列表中。</li><li>这就完成了依赖收集。</li></ul><ol start="2"><li>Vue 的实际实现：</li></ol><p>Vue 的实际实现与我们的简化版本在原理上是相似的，但更加复杂和优化。在 Vue 中，依赖收集确实主要发生在首次渲染过程中，但还有一些细节需要注意：</p><p>a) 编译阶段：</p><ul><li>Vue 首先会将模板编译成渲染函数。</li><li>这个过程发生在数据被实际渲染之前。</li></ul><p>b) 首次渲染：</p><ul><li>当组件挂载时，渲染函数被调用。</li><li>在这个过程中，会创建一个渲染 Watcher。</li><li>渲染 Watcher 被设置为<code>Dep.target</code>。</li><li>然后，渲染函数开始执行，访问数据属性。</li><li>每次访问响应式属性时，都会触发 getter，完成依赖收集。</li></ul><p>c) 动态依赖：</p><ul><li>Vue 的依赖收集是动态的。这意味着即使在首次渲染后，如果模板中使用的数据发生变化（比如 v-if 条件改变），也可能会收集新的依赖或移除旧的依赖。</li></ul><p>d) 计算属性和侦听器：</p><ul><li>这些特殊的属性可能在组件生命周期的不同阶段收集依赖。</li></ul><p>总的来说，Vue 确实主要在第一次渲染真实数据的时候收集依赖。但它也能在后续的更新中动态地调整依赖关系。</p>`,54)]))}const h=a(o,[["render",t]]);export{y as __pageData,h as default};
