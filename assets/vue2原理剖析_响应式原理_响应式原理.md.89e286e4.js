import{_ as s,o as a,c as e,V as n}from"./chunks/framework.ff44d2fd.js";const o="/fe-series-notes/assets/2023-10-12-14-53-03.43a53ce6.png",g=JSON.parse('{"title":"响应式系统","description":"","frontmatter":{},"headers":[],"relativePath":"vue2原理剖析/响应式原理/响应式原理.md","filePath":"vue2原理剖析/响应式原理/响应式原理.md","lastUpdated":1720490741000}'),p={name:"vue2原理剖析/响应式原理/响应式原理.md"},l=n('<h1 id="响应式系统" tabindex="-1">响应式系统 <a class="header-anchor" href="#响应式系统" aria-label="Permalink to &quot;响应式系统&quot;">​</a></h1><p>Vue2 基于<code>Object.defineProperty</code>实现「响应式系统」的。</p><p><img src="'+o+`" alt=""></p><h2 id="演示操作" tabindex="-1">演示操作 <a class="header-anchor" href="#演示操作" aria-label="Permalink to &quot;演示操作&quot;">​</a></h2><p>当点击按钮时，会打印<code>视图更新啦～</code>提示，表示更新数据，视图也会更新。</p><h2 id="实现过程" tabindex="-1">实现过程 <a class="header-anchor" href="#实现过程" aria-label="Permalink to &quot;实现过程&quot;">​</a></h2><ul><li><code>defineReactive</code> 是对一个对象的属性进行响应式处理，get 的时候收集依赖，set 的时候更新视图</li><li><code>observer</code> 是循环遍历对象，对对象的每个顺序进行<code>defineReactive</code>响应式处理</li><li><code>Dep</code>订阅者类，主要是为每一个属性来收集 Watcher 实例</li><li><code>Watcher</code>观察者类，收集依赖，就是在视图中，每一处使用到属性的地方，都会有一个 Watcher 进行监听。</li></ul><p>每个属性，Dep，Watcher 的关系：</p><ul><li>每个属性都有一个 Dep 类，用来收集该属性所有的 Watcher</li><li>在视图中，每一处使用该属性的地方，都会被一个 Watcher 监听</li><li>如果该属性变了，就能从 Dep 中找到所有 Watcher，然后全部应用 Watcher 中的 update 方法，就能一次性更新视图中所有使用到该属性的地方</li></ul><h2 id="缺陷" tabindex="-1">缺陷 <a class="header-anchor" href="#缺陷" aria-label="Permalink to &quot;缺陷&quot;">​</a></h2><p>上面的模拟 Vue 的响应式系统中，在 Vue 类的构造函数中创建了一个全局的 Watcher 对象，<strong>这个 Watcher 会收集所有属性的依赖</strong>，所以实际上是无法区分到底是哪个属性进行了修改。</p><p>而在实际的 Vue 源码中，会对每个属性单独创建 watcher，但是不是在 defineReactive 中创建的，因为在 defineReactive 中创建 Watcher 对象可能会导致问题。defineReactive 是定义在对象的每一个属性上的，如果在这里创建 Watcher，那么每当属性被访问时，都会创建一个新的 Watcher。这显然会导致内存和性能问题。</p><p><strong>在 Vue 框架中，Watcher 对象是在编译模板时，通过在最上层 Vue 实例的 $mount 函数中调用 mountComponent 而新建的。</strong></p><p>当节点中的绑定的表达式被求值时（即在渲染函数中被访问时），就会触发对应的 getter 函数，进行依赖收集。</p><h2 id="补充-组件的渲染-watcher-和每个属性的-watcher" tabindex="-1">补充：组件的渲染 watcher 和每个属性的 watcher <a class="header-anchor" href="#补充-组件的渲染-watcher-和每个属性的-watcher" aria-label="Permalink to &quot;补充：组件的渲染 watcher 和每个属性的 watcher&quot;">​</a></h2><p>在 Vue 2 的源码中，每一个组件（即 Vue 实例）都有一个渲染<code>Watcher</code>，我们通常将其称为渲染<code>Watcher</code>或者组件的<code>Watcher</code>。这个<code>Watcher</code>的工作就是重新渲染整个 Vue 组件。</p><p>在组件中，每个需要动态更新的属性（例如模板中的插值绑定、<code>v-bind</code>绑定或者是计算属性等）都会对应有一个或者多个<code>Watcher</code>。当这些属性的值发生变化时，对应的<code>Watcher</code>会被触发，并且会触发组件的渲染<code>Watcher</code>，从而重新渲染整个 Vue 组件。</p><p>总的来说，一个 Vue 组件会有一个渲染<code>Watcher</code>，以及每个需要动态更新的属性对应的<code>Watcher</code>。这样做的目的是为了实现精确的更新，只有当依赖的数据发生变化时，才会重新计算和重新渲染，这样可以提高性能。</p><p>另外，对于用户自定义的<code>watch</code>，每个<code>watch</code>也都会对应一个<code>Watcher</code>实例。所以，一个 Vue 实例中可能会有多个<code>Watcher</code>实例，包括渲染<code>Watcher</code>、属性<code>Watcher</code>和用户自定义的<code>watch</code>的<code>Watcher</code>。</p><p>比如，让我们用一个图书馆的例子来解释这个概念。</p><p>假设你正在管理一个图书馆。这个图书馆有很多书（这些书对应 Vue 实例中的属性），你要确保所有的书都按时被归还（这对应于确保所有的数据都是最新的）。</p><p>每一本书都有一个专门的图书管理员（对应于每个属性的 <code>Watcher</code>），他们的任务是跟踪这本书何时被借走，何时被归还。当有人借走一本书或者归还一本书时，对应的图书管理员就会记录下这个信息。</p><p>同时图书馆还有一个总管理员（对应于 Vue 实例的渲染 <code>Watcher</code>）。他并不直接管理所有的书，但是当任何一本书的状态发生改变时，对应的图书管理员就会通知他。总管理员的任务就是根据这些信息，确保图书馆的整体运行正常（对应于确保整个 Vue 实例的视图是最新的）。</p><p>所以，总的来说，每一本书都有一个专门的图书管理员，而图书馆有一个总管理员。这就像在 Vue 实例中，每个属性都有一个 <code>Watcher</code>，而整个 Vue 实例也有一个渲染 <code>Watcher</code>。</p><h2 id="代理" tabindex="-1">代理 <a class="header-anchor" href="#代理" aria-label="Permalink to &quot;代理&quot;">​</a></h2><p>那么问题来了，我们需要对 <code>this._data.text</code> 操作才会触发 set。</p><p>为了偷懒，我们需要一种方便的方法通过 <code>this.text</code> 直接设置就能触发 set 对视图进行重绘。</p><p>那么就需要用到代理。</p><p>我们可以在 Vue 的构造函数 constructor 中为 data 执行一个代理<a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js#L33" target="_blank" rel="noreferrer">proxy</a>。这样我们就把 data 上面的属性代理到了 vm 实例上。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">_proxy.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, options.data); </span><span style="color:#6A737D;">/*构造函数中*/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*代理*/</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">_proxy</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">that</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  Object.</span><span style="color:#B392F0;">keys</span><span style="color:#E1E4E8;">(data).</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object.</span><span style="color:#B392F0;">defineProperty</span><span style="color:#E1E4E8;">(that, key, {</span></span>
<span class="line"><span style="color:#E1E4E8;">      configurable: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      enumerable: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">proxyGetter</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> that._data[key];</span></span>
<span class="line"><span style="color:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">proxySetter</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">val</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        that._data[key] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"><span style="color:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>我们就可以用 <code>app.text</code> 代替 <code>app._data.text</code> 了。</p><h2 id="当我把响应式数据写到-template-中时-是如何读取该响应式数据来完成收集依赖的" tabindex="-1">当我把响应式数据写到 template 中时，是如何读取该响应式数据来完成收集依赖的？ <a class="header-anchor" href="#当我把响应式数据写到-template-中时-是如何读取该响应式数据来完成收集依赖的" aria-label="Permalink to &quot;当我把响应式数据写到 template 中时，是如何读取该响应式数据来完成收集依赖的？&quot;">​</a></h2><p>在 Vue 2 中，当你把响应式数据写到模板 (template) 中时，Vue 会通过模板编译过程将模板转换成渲染函数，渲染函数会在组件渲染过程中被调用。在这个过程中，响应式数据的读取会触发它们的 getter，从而完成依赖收集。具体步骤如下：</p><ol><li><p><strong>模板编译（Template Compilation）</strong>： 当你定义一个 Vue 组件并使用模板时，Vue 会将这个模板编译成渲染函数。这一步通常发生在 Vue 的编译阶段，Vue 内部会使用一个模板编译器将模板字符串转换成渲染函数。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;{{ message }}&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>会被编译成类似这样的渲染函数：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">with</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">_c</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;div&#39;</span><span style="color:#E1E4E8;">, [</span><span style="color:#B392F0;">_v</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">_s</span><span style="color:#E1E4E8;">(message))]);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>渲染函数执行（Render Function Execution）</strong>： 当组件实例化时，渲染函数会在组件的上下文中被执行。此时，渲染函数会访问 <code>message</code> 这个响应式数据的值。</p></li><li><p><strong>依赖收集（Dependency Collection）</strong>： 当渲染函数访问 <code>message</code> 时，会触发 <code>message</code> 属性的 getter 方法。由于 Vue 已经设置了一个当前的渲染 Watcher，getter 方法会将这个 Watcher 添加到 <code>message</code> 属性的依赖列表中。</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">defineProperty</span><span style="color:#E1E4E8;">(data, </span><span style="color:#9ECBFF;">&#39;message&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reactiveGetter</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Dep.target) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      dep.</span><span style="color:#B392F0;">addSub</span><span style="color:#E1E4E8;">(Dep.target);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reactiveSetter</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newVal</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (newVal </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> val) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newVal;</span></span>
<span class="line"><span style="color:#E1E4E8;">      dep.</span><span style="color:#B392F0;">notify</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>在上述代码中，当 <code>message</code> 的 getter 被调用时，<code>Dep.target</code>（当前的渲染 Watcher）会被添加到 <code>message</code> 的依赖列表中。</p></li><li><p><strong>通知更新（Notification of Updates）</strong>： 当 <code>message</code> 的值发生变化时，会触发 setter 方法。setter 方法会调用依赖列表中的所有 Watcher 的 <code>update</code> 方法，从而触发组件重新渲染。</p></li><li><p><strong>组件重新渲染（Component Re-rendering）</strong>： 组件的重新渲染会再次执行渲染函数，这个过程会重新收集依赖并更新视图。</p></li></ol><p>总结来说，当你在模板中使用响应式数据时，Vue 会在模板编译成渲染函数并执行时，读取这些数据并触发它们的 getter 方法，从而完成依赖收集。之后，当数据变化时，Vue 会通过依赖列表通知相关的 Watcher 更新视图。</p>`,35),t=[l];function c(r,E,i,d,y,h){return a(),e("div",null,t)}const F=s(p,[["render",c]]);export{g as __pageData,F as default};
