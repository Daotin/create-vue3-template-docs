import{_ as s,o as n,c as a,V as l}from"./chunks/framework.ff44d2fd.js";const p="/fe-series-notes/assets/img-20240520140527.906c3c46.png",o="/fe-series-notes/assets/img-20240520140536.ef9df56e.png",b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"webpack通关秘籍/webpack执行原理.md","filePath":"webpack通关秘籍/webpack执行原理.md","lastUpdated":1716197176000}'),e={name:"webpack通关秘籍/webpack执行原理.md"},c=l(`<h2 id="webpack启动流程" tabindex="-1">webpack启动流程 <a class="header-anchor" href="#webpack启动流程" aria-label="Permalink to &quot;webpack启动流程&quot;">​</a></h2><p>当我们执行npm run dev/build的时候，做了什么操作？</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#9ECBFF;">&quot;scripts&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#79B8FF;">&quot;build&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;wabpack&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>当使用npm run 的时候，实际上执行的是<code>./node_modules/.bin/webpack</code> 指令。</p><blockquote><p>这个webpack指令是哪儿来的？</p></blockquote><p>是在安装webpack的时候，如果安装的包中有bin选项，那么在安装的时候，如果是全局安装，则会放到全局usr/bin目录下（linux），如果是局部安装，则会放到<code>./node_modules/.bin</code>下。</p><p>bin的写法有两种：</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// 第一种：在这种情况下，name字段对应的值将作为命令</span></span>
<span class="line"><span style="color:#9ECBFF;">&quot;bin&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;./bin/webpack.js&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#6A737D;">// 第二种：可以定义多个命令，每个命令指向不同的可执行文件</span></span>
<span class="line"><span style="color:#9ECBFF;">&quot;bin&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">&quot;webpack-cli&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;./bin/cli.js&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">},</span></span></code></pre></div><p>所以，对于webpack为例，实际指向的是<code>./bin/webpack.js</code> 文件。</p><h3 id="webpack的webpack-js做了什么" tabindex="-1">webpack的webpack.js做了什么？ <a class="header-anchor" href="#webpack的webpack-js做了什么" aria-label="Permalink to &quot;webpack的webpack.js做了什么？&quot;">​</a></h3><p>这个脚本是一个Node.js命令行工具的引导程序，用于确保用户安装了必要的webpack命令行工具（CLI），并在需要时自动安装。</p><p>具体流程：</p><ol><li><strong>设置初始退出代码</strong>：将<code>process.exitCode</code>设为0，表示默认情况下程序成功退出。</li><li><strong>定义<code>runCommand</code>函数</strong>：该函数使用<code>child_process</code>模块运行子进程来执行命令，并返回一个Promise，以便处理异步任务。 <ul><li><strong>作用</strong>：用于执行安装命令或其他命令行任务。</li></ul></li><li><strong>定义<code>isInstalled</code>函数</strong>：检查给定的npm包是否已安装。 <ul><li><strong>作用</strong>：用于检测<code>webpack-cli</code>或<code>webpack-command</code>是否已安装。</li></ul></li><li><strong>定义<code>CliOption</code>类型</strong>：定义了一个包含CLI工具信息的对象结构，用于描述可用的CLI选项。</li><li><strong>定义可用CLI列表<code>CLIs</code></strong>：包含两个CLI工具的信息，<code>webpack-cli</code>和<code>webpack-command</code>，并检测它们是否已安装。</li><li><strong>检查已安装的CLI工具</strong>：通过过滤<code>CLIs</code>列表，获取已安装的CLI工具。 <ul><li><strong>作用</strong>：确定用户系统中已安装的CLI工具数量。</li></ul></li><li><strong>如果CLI工具数量为0，处理无已安装CLI工具的情况</strong>： <ul><li>显示安装CLI工具的提示信息。</li><li>检测项目是否使用Yarn作为包管理器。</li><li>提示用户是否要安装<code>webpack-cli</code>。</li><li>根据用户输入，使用<code>npm</code>或<code>yarn</code>安装<code>webpack-cli</code>。</li></ul></li><li><strong>如果CLI工具数量为1，处理已安装一个CLI工具的情况</strong>： <ul><li>加载并执行已安装的CLI工具。</li></ul></li><li><strong>如果CLI工具数量为2，处理安装了多个CLI工具的情况</strong>：</li></ol><ul><li>提示用户只需安装一个CLI工具，并将退出代码设为1。</li></ul><p>最后，如果我们安装了webpack-cli，则会加载并执行<code>webpack-cli</code>，具体的代码为：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(path.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">	path.</span><span style="color:#B392F0;">dirname</span><span style="color:#E1E4E8;">(pkgPath),</span></span>
<span class="line"><span style="color:#E1E4E8;">	pkg.bin[installedClis[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">].binName]</span></span>
<span class="line"><span style="color:#E1E4E8;">));</span></span></code></pre></div><p>最终实际执行的是<code>./bin/cli.js</code>。</p><h3 id="webpack-cli中cli-js做了什么" tabindex="-1">webpack-cli中cli.js做了什么？ <a class="header-anchor" href="#webpack-cli中cli-js做了什么" aria-label="Permalink to &quot;webpack-cli中cli.js做了什么？&quot;">​</a></h3><p>1、导入一些不需要编译的参数。比如init，info等</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { </span><span style="color:#79B8FF;">NON_COMPILATION_ARGS</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;./utils/constants&quot;</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>2、如果命令行参数中有上述不需要编译的参数，直接执行<code>prompt-command.js</code>文件并退出</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">NON_COMPILATION_CMD</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> process.argv.</span><span style="color:#B392F0;">find</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (arg </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;serve&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		global.process.argv </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> global.process.argv.</span><span style="color:#B392F0;">filter</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;serve&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">		process.argv </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> global.process.argv;</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">NON_COMPILATION_ARGS</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">find</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> arg);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">NON_COMPILATION_CMD</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;./utils/prompt-command&quot;</span><span style="color:#E1E4E8;">)(</span><span style="color:#79B8FF;">NON_COMPILATION_CMD</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">process.argv);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><blockquote><p><code>prompt-command.js</code>文件做了什么工作？</p></blockquote><p>主要作用是检查特定的 <code>@webpack-cli</code> 包是否已安装，如果未安装，则提示用户是否安装该包。其执行流程如下：</p><ol><li>构建包的名称和路径，并尝试在本地或全局范围内解析该包的路径。</li><li>如果包已安装，调用 <code>runWhenInstalled</code> 函数继续执行后续逻辑。</li><li>如果包未安装，构建安装命令（使用 <code>npm</code> 或 <code>yarn</code>），并通过 <code>readline</code> 模块向用户提示是否安装该包。</li><li>根据用户的输入： <ul><li>如果用户同意安装，运行安装命令，然后调用 <code>runWhenInstalled</code> 或特定的初始化逻辑。</li><li>如果用户拒绝安装，显示错误信息并设置退出代码为 1。</li></ul></li></ol><p>通过这一流程，函数确保在执行特定命令之前所需的 <code>@webpack-cli</code> 包已经安装。</p><p>比如，init示例如下： <img src="`+p+`" alt=""></p><p>3、引入 yargs，用于解析命令行参数</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">yargs</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;yargs&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">usage</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`webpack-cli \${</span><span style="color:#B392F0;">require</span><span style="color:#9ECBFF;">(</span><span style="color:#9ECBFF;">&quot;../package.json&quot;</span><span style="color:#9ECBFF;">).</span><span style="color:#E1E4E8;">version</span><span style="color:#9ECBFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9ECBFF;">Usage: webpack-cli [options]</span></span>
<span class="line"><span style="color:#9ECBFF;">       webpack-cli [options] --entry &lt;entry&gt; --output &lt;output&gt;</span></span>
<span class="line"><span style="color:#9ECBFF;">       webpack-cli [options] &lt;entries...&gt; --output &lt;output&gt;</span></span>
<span class="line"><span style="color:#9ECBFF;">       webpack-cli &lt;command&gt; [options]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9ECBFF;">For more information, see https://webpack.js.org/api/cli/.\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 引入 config-yargs.js，用于配置 yargs.配置的内容有很多命令的分组。</span></span>
<span class="line"><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;./config/config-yargs&quot;</span><span style="color:#E1E4E8;">)(yargs);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;">*解析命令行参数并处理错误、帮助信息等.</span></span>
<span class="line"><span style="color:#6A737D;">   </span></span>
<span class="line"><span style="color:#6A737D;">   其中，err 为错误信息，argv 为解析后的参数，output 为帮助信息。</span></span>
<span class="line"><span style="color:#6A737D;">   output: </span></span>
<span class="line"><span style="color:#6A737D;">     - 当用户输入有效命令和选项时，output 为空，执行命令逻辑。</span></span>
<span class="line"><span style="color:#6A737D;">     - 当用户请求帮助、版本信息或输入无效命令时，output 包含相应的信息。 </span></span>
<span class="line"><span style="color:#6A737D;">*/</span></span>
<span class="line"><span style="color:#E1E4E8;">yargs.</span><span style="color:#B392F0;">parse</span><span style="color:#E1E4E8;">(process.argv.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">), (</span><span style="color:#FFAB70;">err</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">argv</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">output</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">		Error.stackTraceLimit </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">30</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">// arguments validation failed</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (err </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> output) {</span></span>
<span class="line"><span style="color:#E1E4E8;">			console.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(output);</span></span>
<span class="line"><span style="color:#E1E4E8;">			process.exitCode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">			</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">		}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">// help or version info</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (output) {</span></span>
<span class="line"><span style="color:#E1E4E8;">			console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(output);</span></span>
<span class="line"><span style="color:#E1E4E8;">			</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">		}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (argv.verbose) {</span></span>
<span class="line"><span style="color:#E1E4E8;">			argv[</span><span style="color:#9ECBFF;">&quot;display&quot;</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;verbose&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">		}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">...</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">/*</span></span>
<span class="line"><span style="color:#6A737D;">convert-argv.js文件的作用是解析命令行参数和配置文件，将其转换为 Webpack 可用的配置选项，</span></span>
<span class="line"><span style="color:#6A737D;">并确保所有必要的插件和编译器已正确注册和加载，从而准备好执行 Webpack 构建任务</span></span>
<span class="line"><span style="color:#6A737D;">*/</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> options </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;./utils/convert-argv&quot;</span><span style="color:#E1E4E8;">)(argv);</span></span></code></pre></div><p><code>config-yargs.js</code>配置的分组如下：</p><p>参数分组 (config/config-args.js)，将命令划分为9类：</p><ul><li>Config options: 配置相关参数(文件名称、运行环境等)</li><li>Basic options: 基础参数(entry设置、debug模式设置、watch监听设置、devtool设置)</li><li>Module options: 模块参数，给 loader 设置扩展</li><li>Output options: 输出参数(输出路径、输出文件名称)</li><li>Advanced options: 高级用法(记录设置、缓存设置、监听频率、bail等)</li><li>Resolving options: 解析参数(alias 和 解析的文件后缀设置)</li><li>Optimizing options: 优化参数</li><li>Stats options: 统计参数</li><li>options: 通用参数(帮助命令、版本信息等)</li></ul><p><img src="`+o+`" alt=""></p><p>4、引入webpack，执行编译任务</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">processOptions</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">options</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">processOptions</span><span style="color:#E1E4E8;">(options);</span></span></code></pre></div><p>processOptions具体的执行内容如下：</p><ol><li><strong>处理 Promise</strong>：如果 <code>options</code> 是一个 Promise，则等待其解析后再次调用 <code>processOptions</code>，捕获错误并退出。 如果 Webpack 配置文件是以异步方式加载的，比如动态导入或使用某些插件/工具生成的配置，返回值可能是一个 Promise</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> options.then </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;function&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	options.</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(processOptions).</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">err</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		console.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(err.stack </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> err);</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#6A737D;">// eslint-disable-next-line no-process-exit</span></span>
<span class="line"><span style="color:#E1E4E8;">		process.</span><span style="color:#B392F0;">exit</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">	});</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li><strong>解析并转换统计选项</strong>：根据 <code>options.stats</code> 设置输出选项 <code>outputOptions</code>，并根据命令行参数进一步调整输出选项。 中间大段 ifArg 的代码主要作用是根据命令行参数对 outputOptions 进行动态配置。 ifArg 是一个辅助函数，用于检查命令行参数是否存在，并根据参数值修改相应的 outputOptions 属性。</li></ol><blockquote><p><code>outputOptions</code> 的作用是配置和控制 Webpack 编译过程中的输出信息。 比如我们一般统计包的大小使用webpack-bundle-analyzer，但是也可以使用stats（ <code>webpack --config webpack.prod.js --json &gt; stats.json</code> ）进行初略统计，一般不怎么使用。</p></blockquote><ol start="3"><li><strong>初始化 Webpack 编译器</strong>：根据配置选项创建 Webpack 编译器实例，并处理初始化过程中可能的错误。</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * 这段代码是在使用 webpack 函数创建一个新的 webpack 编译器实例。webpack 是一个模块打包工具，它可以将许多模块转换成静态资源。</span></span>
<span class="line"><span style="color:#6A737D;">  在这段代码中，webpack 函数接收一个参数 options，这是一个对象，包含了一系列配置选项。这些选项可以用来定制 webpack 的行为。</span></span>
<span class="line"><span style="color:#6A737D;">  例如，你可以在 options 对象中指定入口文件、输出路径、加载器等。</span></span>
<span class="line"><span style="color:#6A737D;">  webpack(options) 的返回值是一个 webpack 编译器实例，这个实例被赋值给了 compiler 变量。</span></span>
<span class="line"><span style="color:#6A737D;">  你可以使用这个 compiler 实例来启动编译过程，或者对编译过程进行更细粒度的控制。</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#E1E4E8;">  compiler </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">webpack</span><span style="color:#E1E4E8;">(options);</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><ol start="4"><li><strong>设置进度插件</strong>：如果命令行参数包含 <code>progress</code>，则添加进度插件。</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (argv.progress) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">ProgressPlugin</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;webpack&quot;</span><span style="color:#E1E4E8;">).ProgressPlugin;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ProgressPlugin</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">		profile: argv.profile</span></span>
<span class="line"><span style="color:#E1E4E8;">	}).</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(compiler);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><ol start="5"><li><strong>处理编译回调</strong>：定义 <code>compilerCallback</code> 处理编译后的输出，包括错误处理和结果输出。</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compilerCallback</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">err</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">stats</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 1. 清理缓存</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 2. 处理错误</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 3. 输出编译结果</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 4. 检查错误</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><ol start="6"><li><strong>执行编译或监视</strong>：根据配置选项执行一次性编译或启用文件监视模式。</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// 这行代码检查配置选项 \`firstOptions\` 或 \`options\` 中是否设置了 \`watch\` 属性</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (firstOptions.watch </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> options.watch) { </span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 使用 compiler.watch 方法启用 Webpack 的文件监视模式。watchOptions 包含监视相关的选项，compilerCallback 是编译完成后的回调函数。</span></span>
<span class="line"><span style="color:#E1E4E8;"> compiler.</span><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(watchOptions, compilerCallback);</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 如果没有设置 watch 属性，则执行一次性编译</span></span>
<span class="line"><span style="color:#E1E4E8;">	compiler.</span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">err</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">stats</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span><span style="color:#6A737D;">//...})</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>最后，总结一下<code>cli.js</code>做的内容：</p><ol><li>引入 yargs，对命令行进行定制</li><li>分析命令行参数，对各个参数进行转换，组成编译配置项options</li><li>引用webpack，根据配置项options进行编译和构建。</li></ol><p>compiler到底做了什么？</p>`,51),t=[c];function r(E,i,y,d,u,F){return n(),a("div",null,t)}const k=s(e,[["render",r]]);export{b as __pageData,k as default};
