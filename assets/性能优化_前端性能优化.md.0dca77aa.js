import{_ as l,o,c as n,S as a}from"./chunks/framework.d5a27ec8.js";const e="/fe-series-notes/assets/2023-08-19-10-04-27.a5f0cb7f.png",p="/fe-series-notes/assets/2023-08-19-10-25-30.9e75f169.png",t="/fe-series-notes/assets/img-20240505120563.f2753842.png",r="/fe-series-notes/assets/img-20240505120500.34205c0b.png",c="/fe-series-notes/assets/2023-08-18-16-12-37.3ad8d240.png",i="/fe-series-notes/assets/img-20240503210508.fe3098a5.png",b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"性能优化/前端性能优化.md","filePath":"性能优化/前端性能优化.md","lastUpdated":1715133971000}'),E={name:"性能优化/前端性能优化.md"};function u(g,s,y,d,h,m){return o(),n("div",null,s[0]||(s[0]=[a('<blockquote><p>Update: 2023-08-18</p></blockquote><p>前端性能优化主要分下面几种场景：</p><ul><li><strong>页面加载性能</strong><ul><li><code>首屏加载优化</code>。减少首屏的加载时间。</li><li><code>单个页面加载优化</code>。减少单个界面的加载时间，这与首屏加载优化有些重叠，但更多地关注于页面内的所有资源和内容的加载，而不仅仅是首屏。</li></ul></li><li><strong>页面交互性能</strong><ul><li><code>页面运行时性能优化</code>。如果页面有一些操作，动画效果，跳转页面等有明显卡顿的需要优化。</li></ul></li></ul><h2 id="一、页面加载性能" tabindex="-1">一、页面加载性能 <a class="header-anchor" href="#一、页面加载性能" aria-label="Permalink to &quot;一、页面加载性能&quot;">​</a></h2><h3 id="衡量指标" tabindex="-1">衡量指标 <a class="header-anchor" href="#衡量指标" aria-label="Permalink to &quot;衡量指标&quot;">​</a></h3><p>对于<code>页面加载性能</code>的衡量指标通常会用 Google 所定义的一系列 Web 指标 (Web Vitals) 来进行衡量，如最大内容绘制 (Largest Contentful Paint，缩写为 LCP) 和首次输入延迟 (First Input Delay，缩写为 FID)。</p><p>下面是比较推荐的指标数值：</p><p><img src="'+e+'" alt=""></p><blockquote><p><a href="https://juejin.cn/book/7070324244772716556/section/7071919962620690470" target="_blank" rel="noreferrer">详细 Web Vitals 如何计算？如何衡量网页性能？</a></p></blockquote><h3 id="分析工具" tabindex="-1">分析工具 <a class="header-anchor" href="#分析工具" aria-label="Permalink to &quot;分析工具&quot;">​</a></h3><p>为了提高性能，我们首先需要知道如何衡量它。在这方面，有一些很棒的工具可以提供帮助：</p><p><strong>一、用于本地开发期间的性能分析：</strong></p><p>1、打开浏览器的开发者工具，查看 <code>Network</code> 标签，优化首屏加载的资源。</p><ul><li>统计接口耗时，看是否是接口慢的原因？</li><li>哪些资源加载时间长？是不是有某些资源特别大或者加载时间特别长？</li><li>查看是否有不必要的大型库或资源被加载。例如，有没有加载整个库但只使用其中一小部分的情况？</li><li>图片、视频等媒体资源是否经过了优化？是否可以进一步压缩？</li></ul><p>2、用 <code>Vue Devtool</code> 记录组件耗时，看是否是组件耗时过长</p><p>3、Chrome 开发者工具“Performance”和“<a href="https://github.com/GoogleChrome/lighthouse" target="_blank" rel="noreferrer">Lighthouse</a>”面板</p><blockquote><p>Perfomance 能让我们看到更多细节数据，但是更加复杂，Lighthouse 就比较智能，但是隐藏了更多细节。所以，最好先用Lighthouse来看直观的性能数据，具体的细节再看Performance。</p></blockquote><p>4、开启 <code>app.config.performance = true</code> 将会开启 Vue 特有的性能标记，标记在 Chrome 开发者工具的性能时间线上。</p><p><img src="'+p+'" alt=""></p><p><strong>二、用于生产部署的负载性能分析：</strong></p><ul><li><a href="https://pagespeed.web.dev/" target="_blank" rel="noreferrer">PageSpeed Insights</a></li><li><a href="https://www.webpagetest.org/" target="_blank" rel="noreferrer">WebPageTest</a></li><li>Lighthouse 性能分析工具</li></ul><h3 id="分析过程" tabindex="-1">分析过程 <a class="header-anchor" href="#分析过程" aria-label="Permalink to &quot;分析过程&quot;">​</a></h3><h4 id="_1-利用-lighthouse-生成-web-性能报告" tabindex="-1">1）利用 Lighthouse 生成 Web 性能报告 <a class="header-anchor" href="#_1-利用-lighthouse-生成-web-性能报告" aria-label="Permalink to &quot;1）利用 Lighthouse 生成 Web 性能报告&quot;">​</a></h4><blockquote><p>注意：使用Chrome隐身模式。</p></blockquote><p>我们只关注Web 应用的加载性能，所以勾选第一个 Performance 选项就可以了。</p><p><img src="'+t+'" alt=""></p><p>以B站为例，生成Performance性能报告：</p><p><img src="'+r+'" alt=""></p><p>我们可以发现性能指标下面一共有5项内容，这5项内容分别对应了从 Web 应用的加载到页面展示完成的这段时间中，各个阶段所消耗的时长。</p><ul><li><strong>First Contentful Paint(FCP)</strong>：用户首次看到页面内容的时间点</li><li><strong>Largest Contentful Paint(LCP)</strong>：页面中最大的可见内容元素（比如图片、视频、文本块等）被完全呈现的时间点</li><li><strong>Total Blocking Time(TBT)</strong>：指在加载过程中，主线程被阻塞的时间总和</li><li><strong>Cumulative Layout Shift(CLS)</strong>：衡量页面内容在加载过程中发生的意外布局变化的指标</li><li><strong>Speed Index(SI)</strong>：Speed Index 表明了网页内容的可见填充速度。速度指数越低，意味着页面越快呈现给用户。</li></ul><p>如何优化？参考：<a href="https://developer.chrome.com/docs/lighthouse/performance/performance-scoring?hl=zh-cn" target="_blank" rel="noreferrer">https://developer.chrome.com/docs/lighthouse/performance/performance-scoring?hl=zh-cn</a></p><h4 id="_2-查看performance" tabindex="-1">2）查看Performance <a class="header-anchor" href="#_2-查看performance" aria-label="Permalink to &quot;2）查看Performance&quot;">​</a></h4><p>可以查看<a href="./chrome-devtools-performance.html">chrome-devtools-performance</a>文章。</p><h3 id="_1、首屏加载优化" tabindex="-1">1、首屏加载优化 <a class="header-anchor" href="#_1、首屏加载优化" aria-label="Permalink to &quot;1、首屏加载优化&quot;">​</a></h3><p>并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；</p><p>而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。</p><p>我们把这些能阻塞网页首次渲染的资源称为关键资源。基于关键资源，我们可以继续细化出来3个影响页面首次渲染的核心因素。</p><p>1、减少关键资源个数</p><p>2、减小关键资源大小</p><p>3、降低关键资源的 RTT 次数</p><blockquote><p>关于RTT：什么是 RTT 呢？当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</p></blockquote><h4 id="通用前端优化" tabindex="-1">通用前端优化 <a class="header-anchor" href="#通用前端优化" aria-label="Permalink to &quot;通用前端优化&quot;">​</a></h4><blockquote><p>其他与 Vue 无关的通用优化手段，可以参考这份 <a href="https://web.dev/fast/" target="_blank" rel="noreferrer">web.dev 指南</a>提供了一个全面的总结。</p></blockquote><p><strong>0、关键资源个数：越少越好。</strong></p><p><strong>1、关键资源大小：文件压缩</strong></p><ul><li>JavaScript/CSS/HTML 文件 <ul><li>Gzip 压缩</li><li>代码分割</li><li>移除未使用的代码 Tree-shaking</li></ul></li><li>图片压缩 <ul><li>压缩 TinyPNG</li><li>格式优化 webp/svg</li><li>雪碧图</li><li>懒加载</li></ul></li></ul><p><strong>2、优化 HTTP 请求</strong></p><ul><li>图片懒加载</li><li>浏览器缓存</li><li>使用 CDN</li><li>DNS 缓存</li><li>使用 HTTP2/3</li><li>合并请求（雪碧图）</li><li>并发请求</li><li>本地存储（localStorage）</li><li>防抖和节流</li></ul><p><strong>3、代码执行效率</strong></p><ul><li>使用 Performance 标签，记录页面加载的性能时间线。查看哪些任务执行时间长，是否有可以优化的地方？</li><li>是否有不必要的计算或渲染在首屏加载时执行？</li><li>使用 Web Worker</li></ul><p><strong>4、渲染过程优化：</strong></p><ul><li>预加载 (Preload)：使用 <code>&lt;link rel=&quot;preload&quot; as=&quot;...&quot; href=&quot;...&quot;&gt;</code> 预加载关键资源。</li><li>预获取 (Prefetch)：预获取可能在未来需要的资源，但优先级较低。</li><li>减少 DOM 数量</li></ul><p><strong>5、对于一些第三方库，考虑使用更轻量级的替代方案。</strong></p><p><img src="'+c+`" alt=""></p><h4 id="vue-相关优化" tabindex="-1">Vue 相关优化 <a class="header-anchor" href="#vue-相关优化" aria-label="Permalink to &quot;Vue 相关优化&quot;">​</a></h4><p>1、登录页面优化</p><p>对于 SaaS 系统，一般来说首屏即是登录页，登录有什么地方可以优化的呢？</p><p>一般在登录页，会有一个很大的图片，而如果网络不好的话，加载的速度会很慢，所以优化登录页面的图片加载速度是很关键的。</p><p>（1）尽量使用 <code>webp</code> 的格式</p><p>WebP 的优势在于它具有更优的图像数据压缩算法，在拥有肉眼无法识别差异的图像质量前提下，带来更小的图片体积，同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都非常优秀、稳定和统一。</p><p>（2）先使用一个小的占位图片，等大图片加载完毕后，再替换成大图片</p><blockquote><p>可以采用工具（<a href="https://blurha.sh/%EF%BC%89" target="_blank" rel="noreferrer">https://blurha.sh/）</a> 生成图片的模糊缩略图。</p></blockquote><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * 等到图片加载完成</span></span>
<span class="line"><span style="color:#6A737D;"> * </span><span style="color:#F97583;">@param</span><span style="color:#6A737D;"> </span><span style="color:#E1E4E8;">url</span><span style="color:#6A737D;"> 图片链接</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">waitForImageLoad</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">url</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">request</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">inject</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> img </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Image</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    img.src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url;</span></span>
<span class="line"><span style="color:#E1E4E8;">    img.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;load&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">request</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">      img.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>具体的使用方式：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> LoginBg </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;@/assets/images/login/login-bg.webp?url&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { waitForImageLoad } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;@/utils&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0;">onMounted</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 优化图片加载完成后再替换首页图片</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">dom</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;.login-wrap&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HTMLElement</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">waitForImageLoad</span><span style="color:#E1E4E8;">(LoginBg);</span></span>
<span class="line"><span style="color:#E1E4E8;">    dom</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">.style.backgroundImage </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">\`url(\${</span><span style="color:#E1E4E8;">LoginBg</span><span style="color:#9ECBFF;">})\`</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(error);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre></div><p>这样在第一次加载登录界面的时候，就会很快打开界面。</p><p>2、包体积与 Tree-shaking 优化</p><ul><li>安装<code>rollup-plugin-visualizer</code>插件，该插件用于分析依赖大小占比。</li><li>使用按需引入的依赖（比如使用 lodash-es 替代 lodash）</li></ul><p>3、代码分割</p><blockquote><p>代码分割是指构建工具将构建后的 JavaScript 包拆分为多个较小的，可以按需或并行加载的文件。通过适当的代码分割，页面加载时需要的功能可以立即下载，而额外的块只在需要时才加载，从而提高性能。</p></blockquote><ul><li><p>Vue3 的异步组件</p><ul><li>路由懒加载：虽然没有使用 defineAsyncComponent，但是 vue-router 内部会为您处理这个懒加载部分，并使用 defineAsyncComponent 或相似的方法来确保组件在需要时才加载。</li><li>条件渲染的组件（侧边栏，弹框等）：不是始终在页面上显示的组件，而是基于某些条件才会显示的组件。这可能是由于用户的某些操作，或者基于应用的某些状态。</li></ul></li></ul><p>4、vite 配置优化</p><ul><li>optimizeDeps 预构建依赖</li><li><code>assetsInlineLimit: 4096</code>：静态资源配置，低于配置阈值内联成 base64 编码</li><li>对 manualChunks 进行了拆分优化</li><li>使用 terserOptions 去除 console 和 debugger</li><li><code>cssCodeSplit: true</code>：启用 css 动态拆分</li><li><code>chunkSizeWarningLimit: 500</code>：chunk 大小警告限制，避免打出过大的 chunk 包，影响请求速度。</li><li><code>vite-plugin-compression</code>：开启 gzip 或者 brotli 压缩。</li><li><code>vite-plugin-imagemin</code>：图片压缩工具，支持多种图片格式，配置压缩级别。</li><li>清除无用的 CSS：您可以考虑使用工具像 PurgeCSS 来清除未使用的 CSS，进一步减少文件大小。</li></ul><p>5、<a href="https://www.wolai.com/daotin/jLguSrAjNciqpWn9b4tj8n" target="_blank" rel="noreferrer">BlueLink 项目打包体积优化</a></p><h3 id="_2、单个页面加载优化" tabindex="-1">2、单个页面加载优化 <a class="header-anchor" href="#_2、单个页面加载优化" aria-label="Permalink to &quot;2、单个页面加载优化&quot;">​</a></h3><p>单个页面加载优化与首屏加载优化有许多相似之处，但也有一些特定的考虑因素。当我们谈论单个页面的优化时，我们通常关注的是<code>页面内部的交互</code>、<code>动态内容加载</code>、<code>动画效果</code>等。</p><p>先进行<a href="#首屏加载优化">首屏加载优化</a>，然后针对单个页面加载优化的一些建议和补充：</p><ol><li><p><strong>组件级优化</strong>：</p><ul><li>通过用可视化工具 vueDevtool 分析出耗性能的组件，然后带着目的去优化</li><li><strong>避免不必要的重新渲染</strong>：使用 Vue 的 <code>v-memo</code>、<code>computed</code> 属性或其他缓存策略。</li></ul></li><li><p><strong>动画和过渡效果</strong>：</p><ul><li><strong>使用 <code>requestAnimationFrame</code></strong>：确保动画的流畅性。</li><li><strong>避免强制同步布局</strong>：避免在动画中触发重排。</li><li><strong>使用 GPU 加速</strong>：使用 <code>transform</code> 和 <code>opacity</code> 进行动画，而不是 <code>margin</code>、<code>top</code> 等属性。</li></ul></li><li><p><strong>优化滚动性能</strong>：</p><ul><li><strong>使用虚拟列表</strong>：对于长列表，只渲染当前视口中的项。</li><li><strong>避免滚动时的复杂操作</strong>：如滚动监听中的高开销计算。</li></ul></li><li><p><strong>优化数据加载</strong>：</p><ul><li><strong>分页和无限滚动</strong>：不要一次加载过多数据，使用分页或无限滚动加载更多内容。</li><li><strong>骨架屏或占位符</strong>：在数据加载时显示，提供更好的用户体验。</li></ul></li><li><p><strong>优化图表和可视化</strong>：</p><ul><li><strong>按需渲染</strong>：只渲染视口中的图表或数据。</li><li><strong>使用轻量级库</strong>：如 Chart.js 替代 D3.js（如果不需要 D3 的高级功能）。</li></ul></li><li><p><strong>Web Workers</strong>：</p><ul><li>对于计算密集型任务，考虑在后台线程中执行，避免阻塞主线程。</li></ul></li><li><p><strong>优化嵌入的第三方内容</strong>：</p><ul><li><strong>延迟加载</strong>：如社交媒体插件、广告、地图等。</li><li><strong>使用轻量级替代方案</strong>：如使用静态地图图片替代完整的嵌入式地图。</li></ul></li><li><p><strong>监听事件优化</strong>：</p><ul><li><strong>事件委托</strong>：在父元素上监听事件，而不是每个子元素。</li><li><strong>避免不必要的事件监听</strong>：确保移除不再需要的事件监听器。</li></ul></li><li><p><strong>优化 DOM 操作</strong>：</p></li></ol><ul><li><strong>减少 DOM 查询</strong>：缓存 DOM 元素引用，避免频繁查询。</li><li><strong>批量 DOM 操作</strong>：一次性进行多个操作，避免触发多次重排或重绘。</li></ul><ol start="10"><li>多学习学习 vue 和 react 的设计思路，在我们的开发过程中如果遇到了同样的问题，可以参考这些开源组件的思想解决</li></ol><h2 id="二、页面交互性能优化" tabindex="-1">二、页面交互性能优化 <a class="header-anchor" href="#二、页面交互性能优化" aria-label="Permalink to &quot;二、页面交互性能优化&quot;">​</a></h2><p>谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。</p><p>我们先来看看交互阶段的渲染流水线，在交互阶段没有了加载关键资源和构建 DOM、CSSOM 流程，是从计算样式开始执行。</p><p><img src="`+i+`" alt=""></p><p>大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。如果在计算样式阶段发现有布局信息的修改，那么就会触发<strong>重排</strong>操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。</p><p>同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入<strong>重绘</strong>阶段。</p><p>还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为<strong>合成</strong>。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。</p><p>优化方案：</p><p><strong>1、减少 JavaScript 脚本执行时间，不要一次霸占太久主线程。</strong></p><ul><li>将一次执行的函数分解为多个任务</li><li>耗时且不与DOM操作相关的任务，是有web worker执行</li></ul><p><strong>2、避免强制同步布局</strong> 一般情况下，通过js操作dom，和操作dom后的样式重新计算是放在两个task中的，但是如果在js操作dom后，立即有查询dom相关值的操作，就必须立马计算样式，就会在一个task中完成样式计算，这就相当于延长了当前任务占据主线程的时间。</p><p>如下面代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> main_div </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;mian_div&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> new_node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">createElement</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;li&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> textnode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">createTextNode</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;time.geekbang&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    new_node.</span><span style="color:#B392F0;">appendChild</span><span style="color:#E1E4E8;">(textnode);</span></span>
<span class="line"><span style="color:#E1E4E8;">    document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;mian_div&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">appendChild</span><span style="color:#E1E4E8;">(new_node);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//由于要获取到offsetHeight，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//但是此时的offsetHeight还是老的数据，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//所以需要立即执行布局操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(main_div.offsetHeight)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p><strong>3、尽量使用css动画效果（transition，animation，transform），因为合成的效率更高。</strong> 另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 <code>will-change</code>，这是告诉渲染引擎需要将该元素单独生成一个图层。</p><p>另外，可以通过<a href="./chrome-devtools-performance.html">chrome-devtools-performance</a> 录制一段操作过程进行分析和优化。</p><h2 id="参考文档" tabindex="-1">参考文档 <a class="header-anchor" href="#参考文档" aria-label="Permalink to &quot;参考文档&quot;">​</a></h2><ul><li><a href="https://www.wolai.com/daotin/jLguSrAjNciqpWn9b4tj8n" target="_blank" rel="noreferrer">BlueLink 项目打包体积优化</a></li><li><a href="https://www.yuque.com/lipengzhou/web-performance" target="_blank" rel="noreferrer">前端性能优化专栏</a> 密码：xa3i</li></ul>`,97)]))}const F=l(E,[["render",u]]);export{b as __pageData,F as default};
