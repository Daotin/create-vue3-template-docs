import{_ as e,o as l,c as o,S as a}from"./chunks/framework.d5a27ec8.js";const i="/fe-series-notes/assets/2023-08-17-16-53-18.f4c84f5a.png",g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"性能优化/通过Timing瀑布图分析前端性能问题.md","filePath":"性能优化/通过Timing瀑布图分析前端性能问题.md","lastUpdated":1714745796000}'),n={name:"性能优化/通过Timing瀑布图分析前端性能问题.md"};function r(s,t,d,p,u,c){return l(),o("div",null,t[0]||(t[0]=[a('<h2 id="瀑布图字段含义" tabindex="-1">瀑布图字段含义 <a class="header-anchor" href="#瀑布图字段含义" aria-label="Permalink to &quot;瀑布图字段含义&quot;">​</a></h2><p>瀑布图：是请求不同阶段的图形表示。</p><p><img src="'+i+'" alt=""></p><p>下面是各个字段的解释：</p><h3 id="queueing-队列" tabindex="-1">Queueing 队列 <a class="header-anchor" href="#queueing-队列" aria-label="Permalink to &quot;Queueing 队列&quot;">​</a></h3><p>该请求等待排队时间。可能的原因如下：</p><ul><li>该请求被渲染引擎推迟了，因为它被认为比关键资源（例如脚本/样式）的优先级低。这通常发生在图像上。</li><li>由于浏览器在 HTTP 1 上每个源仅允许6个 TCP 连接，因此该请求被暂停。</li><li>与代理服务器连接进行协商所花费的时间。</li></ul><h3 id="stalled-已停止" tabindex="-1">stalled 已停止 <a class="header-anchor" href="#stalled-已停止" aria-label="Permalink to &quot;stalled 已停止&quot;">​</a></h3><p>浏览器得到要发出这个请求的指令到请求可以发出的等待时间，一般是代理协商，以及等待可复用的 TCP 连接释放的时间，不包括 DNS 查询、建立 TCP 连接的时间</p><h3 id="dns-lookup-dns-查找" tabindex="-1">DNS Lookup DNS 查找 <a class="header-anchor" href="#dns-lookup-dns-查找" aria-label="Permalink to &quot;DNS Lookup DNS 查找&quot;">​</a></h3><p>与代理服务器连接进行协商所花费的时间。每个新域 pagerequires DNS 查找一个完整的往返。 DNS 查询的时间，当本地 DNS 缓存没有的时候，这个时间可能是有一段长度的，但是比如你一旦在 host 中设置了 DNS，或者第二次访问，由于浏览器的 DNS 缓存还在，这个时间就为 0 了。</p><h3 id="initial-connection-初始连接" tabindex="-1">Initial connection 初始连接 <a class="header-anchor" href="#initial-connection-初始连接" aria-label="Permalink to &quot;Initial connection 初始连接&quot;">​</a></h3><p>建立 TCP 连接的时间，就相当于客户端从发请求开始到 TCP 握手结束这一段，包括 DNS 查询+Proxy 时间+TCP 握手时间。</p><h3 id="ssl" tabindex="-1">SSL <a class="header-anchor" href="#ssl" aria-label="Permalink to &quot;SSL&quot;">​</a></h3><p>完成 SSL 握手所花费的时间。</p><blockquote><p>下面是开发中最应该关注的：</p></blockquote><h3 id="request-sent-已发送请求" tabindex="-1">Request sent 已发送请求 <a class="header-anchor" href="#request-sent-已发送请求" aria-label="Permalink to &quot;Request sent 已发送请求&quot;">​</a></h3><p>请求第一个字节发出前到最后一个字节发出后的时间，也就是上传时间。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。</p><h3 id="waiting-ttfb-等待服务器响应" tabindex="-1">Waiting(TTFB) 等待服务器响应 <a class="header-anchor" href="#waiting-ttfb-等待服务器响应" aria-label="Permalink to &quot;Waiting(TTFB) 等待服务器响应&quot;">​</a></h3><p>请求发出后，到收到响应的第一个字节所花费的时间(Time To First Byte),发送请求完毕到接收请求开始的时间;这个时间段就代表服务器处理和返回数据网络延时时间了。服务器优化的目的就是要让这个时间段尽可能短。</p><h3 id="content-download-内容下载" tabindex="-1">Content Download 内容下载 <a class="header-anchor" href="#content-download-内容下载" aria-label="Permalink to &quot;Content Download 内容下载&quot;">​</a></h3><p>收到响应的第一个字节，到接受完最后一个字节的时间，就是下载时间。</p><h2 id="如何根据瀑布图进行优化" tabindex="-1">如何根据瀑布图进行优化 <a class="header-anchor" href="#如何根据瀑布图进行优化" aria-label="Permalink to &quot;如何根据瀑布图进行优化&quot;">​</a></h2><p><strong>1、Started 过长</strong></p><p>Started = Queued + Queueing</p><p>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。</p><ul><li>检查静态资源是否过大，导致请求延后，将资源进行分包</li><li>检查请求是否链式调用（比如是否使用了<code>Promise.all</code>），可以考虑将请求同步发起，如果真的是后一个请求依赖前一个请求，考虑是否有更好的方案</li></ul><p>解决方案：</p><ol><li>可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为域名分片技术。</li><li>建议你把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</li></ol><p><strong>2、Stalled 停滞过长</strong> 通常表示请求在真正开始之前等待的时间。这个时间段可能包括代理协商、队列等待时间以及其他延迟。当你在浏览器的网络面板中看到一个请求的 Stalled 时间过长，这可能是由以下原因引起的：</p><ul><li><strong>超出了最大并发连接数</strong>：如前所述，浏览器对于同一域名的并发请求有限制。如果同时发出多个请求，超出这个限制的请求将被放入队列中等待，这会增加停滞时间。</li><li><strong>代理协商</strong>：如果你使用了代理服务器，请求可能需要一些时间来与代理服务器协商。</li><li><strong>磁盘缓存查找</strong>：如果浏览器正在查找资源的磁盘缓存，这也可能导致停滞延迟。</li><li><strong>等待前一个请求完成</strong>：例如，一个请求可能需要另一个请求的结果作为输入。</li></ul><p>为了优化<code>Stalled</code>时间，你可以考虑以下策略：</p><ul><li><strong>减少请求数量</strong>： <ul><li>合并小文件（如 CSS 或 JavaScript 文件）。</li><li>使用雪碧图或 SVG 符号来合并多个图像。</li><li>使用 Web 字体子集，只加载所需的字符。</li></ul></li><li><strong>使用 HTTP/2</strong>：如前所述，HTTP/2 支持多路复用，可以减少停滞时间。</li><li><strong>避免使用代理</strong>：如果可能的话，尝试直接连接到服务器，而不是通过代理。</li><li><strong>优化缓存策略</strong>：确保资源被正确地缓存，以减少对磁盘缓存的查找。</li><li><strong>优先处理关键请求</strong>：确保关键资源的请求优先于其他非关键资源。</li><li><strong>使用 CDN</strong>：使用内容分发网络（CDN）可以减少请求的往返时间，从而减少停滞时间。</li></ul><p><strong>3、DNS 查找过长</strong></p><ul><li>使用浏览器缓存或 DNS 预解析技术。</li></ul><blockquote><p>DNS 预解析：<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//example.com&quot;&gt;</code></p><p>除了 <code>dns-prefetch</code>，还有其他预解析技术，如 <code>preconnect</code>，它不仅解析 DNS，还预先建立 TCP 连接和 TLS 握手（如果是 HTTPS）。</p></blockquote><p><strong>4、Waiting(TTFB)  过长</strong></p><ul><li>先与后端沟通接口是否可以调优（优化后端逻辑，数据库查询，减少服务器的计算时间等）</li><li>网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。可以使用 CDN 来缓存一些静态文件。</li><li>发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li></ul><p><strong>5、Content Download 过长</strong></p><ul><li>接口响应长（是否多返回了无用的字段）</li><li>压缩响应数据，使用 Gzip 或 Brotli。</li></ul>',40)]))}const q=e(n,[["render",r]]);export{g as __pageData,q as default};
