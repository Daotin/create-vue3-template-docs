import{_ as s,o as n,c as a,V as p}from"./chunks/framework.ff44d2fd.js";const F=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器工作原理/16-WebAPI：setTimeout是如何实现的？.md","filePath":"浏览器工作原理/16-WebAPI：setTimeout是如何实现的？.md","lastUpdated":1712818751000}'),o={name:"浏览器工作原理/16-WebAPI：setTimeout是如何实现的？.md"},l=p(`<p>上一章我们知道，执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。</p><p><strong>那么如何设计？</strong></p><p>在 Chrome 中，除了正常使用的消息队列之外，还有另外一个消息队列<strong>延迟队列</strong>，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</p><p><strong>现在延时代码是如何执行的呢？</strong></p><p>当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数自身、当前发起时间、延迟执行时间。然后将这个回调任务放入延迟队列中。接着正常往下执行消息队列中的任务。</p><p>在当前消息队列中的任务执行完成后，查看延迟队列的任务延时时间是否到了，如果还没到继续执行下一个消息队列的任务；如果到了，则执行延迟队列的任务。</p><p>如果在执行一个消息队列的任务的时候，延迟队列的任务时间到了，那也不能立即执行，得等消息队列的当前任务执行完成后，才能执行这个延迟任务，而且延迟任务的执行也是按顺序执行的，很多个延迟队列的任务时间都到了也得按照先进延迟队列的先执行。</p><p>所以，基于上面的原理，如果当前消息队列的任务执行太久，或者延迟队列的任务排名太靠后，那么这个延迟时间就不准了。</p><h2 id="settimeout注意事项" tabindex="-1">setTimeout注意事项 <a class="header-anchor" href="#settimeout注意事项" aria-label="Permalink to &quot;setTimeout注意事项&quot;">​</a></h2><p>1、延时不准的问题</p><p>2、如果 setTimeout 存在嵌套调用，那么延时时间最短为 4 ms。</p><p>（一般如果使用 setTimeout 来做动画的时候，都是需要 setTimeout 嵌套调用，那么对于实时性很高的动画就不适用了。）</p><p>3、在未激活的页面中的 setTimeout 执行的最小间隔为 1000ms ，这是浏览器干预的，为了欧化后台页面的加载损耗以及降低耗电量。</p><p>4、延时时间有最大值。（ Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行）</p><p>5、如果 setTimeout 的回调函数是一个对象中的一个方法属性，那么这个方法中的 this 会变成 window。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> obj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">show</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(obj.show, </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><p>解决办法：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#6A737D;">// 方式一</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">    obj.</span><span style="color:#B392F0;">show</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 方式二</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    obj.</span><span style="color:#B392F0;">show</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 方式三</span></span>
<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(obj.show.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(obj), </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">);</span></span></code></pre></div><h2 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h2><p><em>requestAnimationFrame 与 setTimeout 区别于联系？</em></p><p>requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p><p>requestAnimationFrame的优势，在于充分利用显示器的刷新机制，比较节省系统资源。显示器有固定的刷新频率（60Hz或75Hz），也就是说，每秒最多只能重绘60次或75次，requestAnimationFrame的基本思想就是与这个刷新频率保持同步，利用这个刷新频率进行页面重绘。此外，使用这个API，一旦页面不处于浏览器的当前标签，就会自动停止刷新。这就节省了CPU、GPU和电力。</p><p>语法：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> requestID </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> window.</span><span style="color:#B392F0;">requestAnimationFrame</span><span style="color:#E1E4E8;">(callback);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 取消回调函数</span></span>
<span class="line"><span style="color:#E1E4E8;">window.</span><span style="color:#B392F0;">cancelAnimationFrame</span><span style="color:#E1E4E8;">(requestID)</span></span></code></pre></div><p>考虑到兼容性：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">window.requestAnimFrame </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">  window.requestAnimationFrame       </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              window.webkitRequestAnimationFrame </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              window.mozRequestAnimationFrame    </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              window.oRequestAnimationFrame      </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              window.msRequestAnimationFrame     </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">( </span><span style="color:#FFAB70;">callback</span><span style="color:#E1E4E8;"> ){</span></span>
<span class="line"><span style="color:#E1E4E8;">                window.</span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(callback, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">60</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">              };</span></span>
<span class="line"><span style="color:#E1E4E8;">    })();</span></span></code></pre></div>`,26),e=[l];function t(c,r,E,i,y,m){return n(),a("div",null,e)}const d=s(o,[["render",t]]);export{F as __pageData,d as default};
