import{_ as s,o as a,c as n,V as p}from"./chunks/framework.ff44d2fd.js";const l="/fe-series-notes/assets/img-20240501210580.9a938b31.png",o="/fe-series-notes/assets/img-20240501210580-1.cdd6306f.png",e="/fe-series-notes/assets/img-20240501220511.ad04eccf.png",t="/fe-series-notes/assets/img-20240501220586.7dc78514.png",c="/fe-series-notes/assets/img-20240501220563.13531d4b.png",E="/fe-series-notes/assets/img-20240501220582.f31744a8.png",b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器工作原理/JavaScript执行机制.md","filePath":"浏览器工作原理/JavaScript执行机制.md","lastUpdated":1714615917000}'),r={name:"浏览器工作原理/JavaScript执行机制.md"},y=p('<h2 id="执行上下文" tabindex="-1">执行上下文 <a class="header-anchor" href="#执行上下文" aria-label="Permalink to &quot;执行上下文&quot;">​</a></h2><p>理解了底层（执行上下文），上层的<a href="https://daotin.github.io/posts/2019/05/16/js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html" target="_blank" rel="noreferrer">变量提升</a>，作用域，闭包就理解了。</p><p>但，实际上，变量定义的位置并没有改变，而是因为经过了编译过程。</p><p>编译的时候，会把这些提升放到一个叫「变量环境」的地方。剩下的部分放在「可执行代码」部分。</p><p>执行代码的时候，缺什么就到变量环境去找。</p><p>主要是理解js代码是「<strong>先编译，再执行</strong>」的。</p><p><img src="'+l+`" alt=""></p><p>执行上下文的范围分3种：</p><ul><li>全局执行上下文</li><li>函数体执行上下文</li><li>eval执行上下文</li></ul><h2 id="调用栈" tabindex="-1">调用栈 <a class="header-anchor" href="#调用栈" aria-label="Permalink to &quot;调用栈&quot;">​</a></h2><blockquote><p>调用栈就是用来管理函数调用关系的一种数据结构。</p></blockquote><p>当有多个执行上下文的时候，通过栈（后进先出）的结构，进行管理和调用。</p><p>类似下面这样的结构，当函数执行完后，就会从栈顶弹出：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">,</span><span style="color:#FFAB70;">c</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> b</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">c</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">addAll</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">,</span><span style="color:#FFAB70;">c</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> d </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10</span></span>
<span class="line"><span style="color:#E1E4E8;">	result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(b,c)</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">  a</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">result</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">d</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">addAll</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">,</span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">)</span></span></code></pre></div><p><img src="`+o+`" alt=""></p><h2 id="块级作用域" tabindex="-1">块级作用域 <a class="header-anchor" href="#块级作用域" aria-label="Permalink to &quot;块级作用域&quot;">​</a></h2><p>由于变量提升，导致很多意料之外的结果，所以引入了let和const，也就有了块级作用域。</p><p>那么，let/const是如何影响执行上下文的？</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> d </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span></span>
<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(a)</span></span>
<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(b)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(b) </span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(c)</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(d)</span></span>
<span class="line"><span style="color:#E1E4E8;">}   </span></span>
<span class="line"><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">()</span></span></code></pre></div><p>a,c会被提取到「变量环境」，但是let定义的变量不会，而是放到之前一直没提到的「词法环境」</p><p>而且，当执行到b=2的时候，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中。</p><p><img src="`+e+'" alt=""></p><p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。</p><p>执行代码的时候，变量的查找，就从:沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</p><p><img src="'+t+`" alt=""></p><p>因此，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时<strong>支持了变量提升和块级作用域</strong>了。</p><h2 id="作用域链" tabindex="-1">作用域链 <a class="header-anchor" href="#作用域链" aria-label="Permalink to &quot;作用域链&quot;">​</a></h2><p>下面代码打印什么？是按照调用栈的顺序来查找变量的吗？然后打印“极客邦”？</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">bar</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(myName)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> myName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;极客邦&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">bar</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> myName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;极客时间&quot;</span></span>
<span class="line"><span style="color:#B392F0;">foo</span><span style="color:#E1E4E8;">()</span></span></code></pre></div><p><img src="`+c+'" alt=""></p><p>非也。打印的是“极客时间”。why？这就涉及到作用域链了。</p><p>其实，在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。</p><p>比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。</p><p><img src="'+E+'" alt=""></p><p>可以看到是指向全局执行上下文的，为什么呢？</p><p>这里就涉及到词法作用域了，作用域链是由<code>词法作用域</code>决定的。</p><h3 id="词法作用域" tabindex="-1">词法作用域 <a class="header-anchor" href="#词法作用域" aria-label="Permalink to &quot;词法作用域&quot;">​</a></h3><p>词法作用域就是指：作用域是由代码中<strong>函数声明的位置</strong>来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</p><p>静态的意思是：词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。</p>',39),i=[y];function F(d,u,g,_,h,m){return a(),n("div",null,i)}const f=s(r,[["render",F]]);export{b as __pageData,f as default};
