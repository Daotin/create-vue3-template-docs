import{_ as e,o as a,c as p,S as s}from"./chunks/framework.d5a27ec8.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"浏览器工作原理/已归档/17-WebAPI：XMLHttpRequest是怎么实现的？.md","filePath":"浏览器工作原理/已归档/17-WebAPI：XMLHttpRequest是怎么实现的？.md","lastUpdated":1714728555000}'),r={name:"浏览器工作原理/已归档/17-WebAPI：XMLHttpRequest是怎么实现的？.md"};function n(o,t,i,l,m,u){return a(),p("div",null,t[0]||(t[0]=[s('<p>先来看个“XMLHttpRequest 运行机制”图：</p><p><img src="https://i.loli.net/2019/09/21/bn6SyhOXvEYTgGa.png" alt="image.png"></p><h2 id="ajax请求是怎么执行的" tabindex="-1">Ajax请求是怎么执行的 <a class="header-anchor" href="#ajax请求是怎么执行的" aria-label="Permalink to &quot;Ajax请求是怎么执行的&quot;">​</a></h2><p>Ajax请求的创建就不说了，从发送的时候说起。</p><p>当调用“xhr.send();” 的时候：</p><p>渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并<strong>添加到消息队列</strong>中（这种机制和setTimeout添加到延迟队列是不同的），等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。</p><h2 id="xmlhttprequest-的一些坑" tabindex="-1">XMLHttpRequest 的一些坑 <a class="header-anchor" href="#xmlhttprequest-的一些坑" aria-label="Permalink to &quot;XMLHttpRequest 的一些坑&quot;">​</a></h2><p>1、跨域问题，浏览器的同源策略。</p><p>2、HTTPS 混合内容</p><p>HTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。</p><p>当<strong>通过 HTML 文件</strong>加载的混合资源，会给出警告，但大部分类型还是能加载的。</p><p><img src="https://i.loli.net/2019/09/21/atNvKA5mhirluM2.png" alt="image.png"></p><p>而在HTTPS页面<strong>通过 XMLHttpRequest 请求</strong>相同的HTTP资源（比如上面的图片）时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。</p><p><img src="https://i.loli.net/2019/09/21/rCuVKapUm3LTlwx.png" alt="image.png"></p>',14)]))}const d=e(r,[["render",n]]);export{c as __pageData,d as default};
