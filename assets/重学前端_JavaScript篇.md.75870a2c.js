import{_ as s,o as a,c as n,V as l}from"./chunks/framework.ff44d2fd.js";const o="/fe-series-notes/assets/img-20240508140582.011897ae.png",F=JSON.parse('{"title":"JavaScript-1：关于类型，有哪些你不知道的细节？","description":"","frontmatter":{},"headers":[],"relativePath":"重学前端/JavaScript篇.md","filePath":"重学前端/JavaScript篇.md","lastUpdated":1715154151000}'),p={name:"重学前端/JavaScript篇.md"},e=l(`<h1 id="javascript-1-关于类型-有哪些你不知道的细节" tabindex="-1">JavaScript-1：关于类型，有哪些你不知道的细节？ <a class="header-anchor" href="#javascript-1-关于类型-有哪些你不知道的细节" aria-label="Permalink to &quot;JavaScript-1：关于类型，有哪些你不知道的细节？&quot;">​</a></h1><h2 id="关于类型-有哪些你不知道的细节" tabindex="-1">关于类型，有哪些你不知道的细节？ <a class="header-anchor" href="#关于类型-有哪些你不知道的细节" aria-label="Permalink to &quot;关于类型，有哪些你不知道的细节？&quot;">​</a></h2><p>根据最新的语言标准，JavaScript有7种语言类型：</p><ol><li>Undefined；</li><li>Null；</li><li>Boolean；</li><li>String；</li><li>Number；</li><li>Symbol（ES6新加入）；</li><li>Object。</li></ol><h3 id="为什么有的编程规范要求用-void-0-代替-undefined" tabindex="-1">为什么有的编程规范要求用 void 0 代替 undefined？ <a class="header-anchor" href="#为什么有的编程规范要求用-void-0-代替-undefined" aria-label="Permalink to &quot;为什么有的编程规范要求用 void 0 代替 undefined？&quot;">​</a></h3><p>Undefined类型的值只有一个 undefined。</p><p>任何一个变量未赋值前值都为 undefined，一般我们使用全局变量 undefined 表示，但是由于 undefined 是个变量，是可以被修改的，所以我们一般使用 <code>void 0</code> 的返回值（<strong>void 运算符</strong> 可以对给定的表达式进行求值，然后返回 <code>undefined</code>）来代替 undefined 变量。</p><blockquote><p>PS：根据ES5的规范，在现代浏览器中，全局的undefined的值将不可修改。但是在局部环境是可以被赋值的！！</p></blockquote><p>Null类型的值只有一个 null，表示一个变量定义了但是为空。</p><p>所以，在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是从未赋值的自然状态。</p><p>还有null是关键字，而不是变量，可以放心使用。</p><h3 id="字符串是否有最大长度" tabindex="-1">字符串是否有最大长度？ <a class="header-anchor" href="#字符串是否有最大长度" aria-label="Permalink to &quot;字符串是否有最大长度？&quot;">​</a></h3><p>String 有最大长度是 <code>2^53 - 1</code>，但是这个所谓最大长度，并不完全是你理解中的字符数。</p><p>因为 JavaScript 中的String类型存储的方式是 <code>UTF16</code>格式的，所以 String 的最大长度指的是保存为UTF16格式时候的最大程度，转化成 字符数的话肯定不到一半长度。。但是肯定够日常使用了。</p><h3 id="为什么在-javascript-中-0-1-0-2-不能-0-3" tabindex="-1">为什么在 JavaScript 中，0.1+0.2 不能 =0.3？ <a class="header-anchor" href="#为什么在-javascript-中-0-1-0-2-不能-0-3" aria-label="Permalink to &quot;为什么在 JavaScript 中，0.1+0.2 不能 =0.3？&quot;">​</a></h3><p>答：计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失，当这些丢失精度的二进制转换成十进制就造成上面的错误了。</p><blockquote><p>另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。</p></blockquote><p><strong>浮点数的比较</strong></p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">( </span><span style="color:#79B8FF;">0.1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0.2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0.3</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// false</span></span></code></pre></div><p>上面的代码输出的结果是 false，说明两边不相等的。</p><p>这里输出的结果是 false，说明两边不相等的，这是浮点运算的特点，也是很多同学疑惑的来源，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。</p><p>所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">( Math.</span><span style="color:#B392F0;">abs</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0.1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0.2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0.3</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> Number.EPSILON); </span><span style="color:#6A737D;">// true</span></span></code></pre></div><p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。</p><h3 id="什么是symbol类型" tabindex="-1">什么是Symbol类型？ <a class="header-anchor" href="#什么是symbol类型" aria-label="Permalink to &quot;什么是Symbol类型？&quot;">​</a></h3><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">();</span></span></code></pre></div><p>上面代码中，变量s就是一个独一无二的值，像一个独一无二的字符串，但是又不是一个字符串类型。</p><p>typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p><blockquote><p>注意：Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></blockquote><p>Symbol函数可以接受一个字符串作为参数，表示<strong>对 Symbol 实例的描述</strong>，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;bar&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">s1 </span><span style="color:#6A737D;">// Symbol(foo)</span></span>
<span class="line"><span style="color:#E1E4E8;">s2 </span><span style="color:#6A737D;">// Symbol(bar)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">s1.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// &quot;Symbol(foo)&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">s2.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">// &quot;Symbol(bar)&quot;</span></span></code></pre></div><p>上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">obj</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;abc&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">sym</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8;">sym </span><span style="color:#6A737D;">// Symbol(abc)</span></span></code></pre></div><blockquote><p><strong>注意</strong>，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的（虽然描述看起来是相同的）。</p></blockquote><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;aaa&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> s1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;aaa&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(s,s1,s</span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;">s1); </span><span style="color:#6A737D;">// Symbol(aaa) Symbol(aaa) false</span></span></code></pre></div><p>以上参考链接：<a href="https://www.cnblogs.com/sunshineForFuture/p/10432440.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/sunshineForFuture/p/10432440.html</a></p><h3 id="为什么给对象添加的方法能用在基本类型上" tabindex="-1">为什么给对象添加的方法能用在基本类型上？ <a class="header-anchor" href="#为什么给对象添加的方法能用在基本类型上" aria-label="Permalink to &quot;为什么给对象添加的方法能用在基本类型上？&quot;">​</a></h3><p>JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”（你看他们长得一模一样）。它们是：</p><ul><li>Number；</li><li>String；</li><li>Boolean；</li><li>Symbol。</li></ul><p>所以，我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。</p><p>Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。</p><p>Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。</p><p>回答上面的问题，为什么给对象添加的方法能用在基本类型上？</p><p>答案就是，<strong>运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。</strong></p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">123</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(num.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">//  num被悄悄转换成临时对象 new Number(123)</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;abc&quot;</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">charAt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)); </span><span style="color:#6A737D;">// &#39;abc&#39; 字符串被悄悄转换成临时对象 new String(&#39;abc&#39;)</span></span></code></pre></div><h3 id="装箱转换和拆箱转换" tabindex="-1">装箱转换和拆箱转换 <a class="header-anchor" href="#装箱转换和拆箱转换" aria-label="Permalink to &quot;装箱转换和拆箱转换&quot;">​</a></h3><p>每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象。</p><p>前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> symbolObject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(){ </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">; }).</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> symbolObject); </span><span style="color:#6A737D;">//object</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(symbolObject </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(symbolObject.</span><span style="color:#79B8FF;">constructor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Symbol); </span><span style="color:#6A737D;">//true</span></span></code></pre></div><p>我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。</p><p>我们可以用 console.log 看一下这个东西的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象。</p><p>装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。</p><p>使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> symbolObject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> symbolObject); </span><span style="color:#6A737D;">//object</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(symbolObject </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(symbolObject.</span><span style="color:#79B8FF;">constructor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Symbol); </span><span style="color:#6A737D;">//true</span></span></code></pre></div><p>每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> symbolObject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">Object</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.toString.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(symbolObject)); </span><span style="color:#6A737D;">//[object Symbol]</span></span></code></pre></div><p>在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。</p><p><strong>拆箱转换</strong>，就是把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。</p><p>拆箱转换会尝试调用 <code>valueOf</code> 和<code> toString</code> 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p><p>如下面的例子：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;"> : () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;valueOf&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {}},</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;"> : () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;toString&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {}}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">o </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#6A737D;">// valueOf</span></span>
<span class="line"><span style="color:#6A737D;">// toString</span></span>
<span class="line"><span style="color:#6A737D;">// TypeError</span></span></code></pre></div><p>我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o*2 这个运算的时候（一个对象乘以2，那么js会想把o转换成Number基本类型，会调用valueOf，并期望返回一个基本类型，但是返回的却是一个对象。。），你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。</p><p>如果将valueOf的返回值改为任意基本类型就会拆箱成功，如：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;"> : () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;valueOf&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">},</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;"> : () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;toString&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {}}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>valueOf，和toString的执行顺序默认是valueOf先，然后是toString。</p></blockquote><h3 id="typeof-类型判断准确吗" tabindex="-1">typeof 类型判断准确吗？ <a class="header-anchor" href="#typeof-类型判断准确吗" aria-label="Permalink to &quot;typeof 类型判断准确吗？&quot;">​</a></h3><p>事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。我们可以看下表来对照一下。</p><p><img src="`+o+`" alt=""></p><p>在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。</p><h1 id="javascript-2-面向对象-vs-javascript中的面向对象" tabindex="-1">JavaScript-2：面向对象 vs JavaScript中的面向对象 <a class="header-anchor" href="#javascript-2-面向对象-vs-javascript中的面向对象" aria-label="Permalink to &quot;JavaScript-2：面向对象 vs JavaScript中的面向对象&quot;">​</a></h1><p>对象的特征如下：</p><ul><li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li><li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li><li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li></ul><p>JavaScript 中对象独有的特色是：<strong>对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。</strong> 如果你用过 Java 或者其它别的语言，肯定会产生跟我一样的感受。</p><h2 id="javascript-对象的两类属性" tabindex="-1">JavaScript 对象的两类属性 <a class="header-anchor" href="#javascript-对象的两类属性" aria-label="Permalink to &quot;JavaScript 对象的两类属性&quot;">​</a></h2><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。</p><p>属性又分为：<strong>数据属性和访问器(getter/setter)属性</strong>。</p><h3 id="数据属性" tabindex="-1">数据属性 <a class="header-anchor" href="#数据属性" aria-label="Permalink to &quot;数据属性&quot;">​</a></h3><p>数据属性具有4个特征：</p><ul><li><code>value</code>：就是属性的值。</li><li><code>writable</code>：决定属性能否被赋值。</li><li><code>enumerable</code>：决定 for in 能否枚举该属性。</li><li><code>configurable</code>：决定该属性能否被删除或者改变特征值。</li></ul><p>在大多数情况下，我们只关心数据属性的值即可。</p><h3 id="访问器-getter-setter-属性" tabindex="-1">访问器(getter/setter)属性 <a class="header-anchor" href="#访问器-getter-setter-属性" aria-label="Permalink to &quot;访问器(getter/setter)属性&quot;">​</a></h3><p>访问器(getter/setter)属性也具有4个特征：</p><ul><li><code>getter</code>：函数或 undefined，在取属性值时被调用。</li><li><code>setter</code>：函数或 undefined，在设置属性值时被调用。</li><li><code>enumerable</code>：决定 for in 能否枚举该属性。</li><li><code>configurable</code>：决定该属性能否被删除或者改变特征值。</li></ul><p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p><p>我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。</p><p>我们可以使用内置函数 <code>Object.getOwnPropertyDescripter</code> 来查看，如以下代码所示：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { a: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> };</span></span>
<span class="line"><span style="color:#E1E4E8;">o.b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">//a 和 b 皆为数据属性</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">getOwnPropertyDescriptor</span><span style="color:#E1E4E8;">(o,</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// {value: 1, writable: true, enumerable: true, configurable: true}</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">getOwnPropertyDescriptor</span><span style="color:#E1E4E8;">(o,</span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// {value: 2, writable: true, enumerable: true, configurable: true}</span></span></code></pre></div><p>如果我们要想改变属性的特征，或者定义访问器属性，我们可以使用 <code>Object.defineProperty</code>，示例如下：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { a: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> };</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">defineProperty</span><span style="color:#E1E4E8;">(o, </span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">, {value: </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, writable: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, enumerable: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, configurable: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#6A737D;">//a和b都是数据属性，但特征值变化了</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">getOwnPropertyDescriptor</span><span style="color:#E1E4E8;">(o,</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// {value: 1, writable: true, enumerable: true, configurable: true}</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">getOwnPropertyDescriptor</span><span style="color:#E1E4E8;">(o,</span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// {value: 2, writable: false, enumerable: false, configurable: true}</span></span>
<span class="line"><span style="color:#E1E4E8;">o.b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(o.b); </span><span style="color:#6A737D;">// 2</span></span></code></pre></div><p>在创建对象时，也可以使用 <code>get</code> 和 <code>set</code> 关键字来创建访问器属性，代码如下所示：</p><div class="language-JavaScript"><button title="Copy Code" class="copy"></button><span class="lang">JavaScript</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">get</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;getter&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">    },</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">set</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">val</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;setter&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">o.a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">123</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(o.a); </span><span style="color:#6A737D;">// setter getter 123</span></span></code></pre></div><p>实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以<strong>字符串或者 Symbol</strong> 为 key，以<strong>数据属性特征值或者访问器属性特征值</strong>为 value。</p><p>比如上面 a 为对象o的key，访问器属性或者<code>{writable:true,value:1,configurable:true,enumerable:true}</code> 为value。</p><p>到这里，可以理解有人得出 “JavaScript 不是面向对象” 的说法， 但是 JavaScript 提供了完全运行时的对象系统，这使得它可以模仿多数面向对象编程范式，所以它也是正统的面向对象语言。</p><p>JavaScript 语言标准也已经明确说明，JavaScript 是一门面向对象的语言，我想标准中能这样说，正是因为 JavaScript 的高度动态性的对象系统。</p><h1 id="javascript-3-js需要模拟类吗" tabindex="-1">JavaScript-3：JS需要模拟类吗？ <a class="header-anchor" href="#javascript-3-js需要模拟类吗" aria-label="Permalink to &quot;JavaScript-3：JS需要模拟类吗？&quot;">​</a></h1><p>JavaScript 本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样，所以才会出现将JavaScript模拟类的操作。</p><p>从 ES6 开始，JavaScript 提供了 <code>class</code>关键字来定义类，尽管，这样的方案仍然是<strong>基于原型运行时系统的模拟</strong>，但是它修正了之前的一些常见的“坑”，统一了社区的方案，这对语言的发展有着非常大的好处。</p><p>其实当初 Brendan 当年选择的<strong>原型系统</strong>，就是一个非常优秀的抽象对象的形式。</p><h2 id="javascript原型" tabindex="-1">JavaScript原型 <a class="header-anchor" href="#javascript原型" aria-label="Permalink to &quot;JavaScript原型&quot;">​</a></h2><p>可以用两条进行概括：</p><ul><li>如果所有对象都有私有字段 <code>[[prototype]]</code>，就是对象的原型；</li><li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li></ul><p>ES6 以来，JavaScript 提供了一系列内置函数，以便更为直接地访问操纵原型。</p><p>三个方法分别为：</p><ul><li><code>Object.create</code> 根据指定的原型创建新对象，原型可以是 null；</li><li><code>Object.getPrototypeOf</code> 获得一个对象的原型；</li><li><code>Object.setPrototypeOf</code> 设置一个对象的原型。</li></ul><hr><p>后续补充，太难了。。。😭</p>`,109),t=[e];function c(r,E,y,i,u,d){return a(),n("div",null,t)}const g=s(p,[["render",c]]);export{F as __pageData,g as default};
