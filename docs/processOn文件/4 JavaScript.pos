{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_right","leftChildren":[],"title":"JavaScript","root":true,"theme":"caihongpao","children":[{"id":"79ed9bf78722","title":"语言类型","link":{"title":"关于类型，有哪些你不知道的细节？","value":"https://github.com/Daotin/front-end-notes/issues/9","type":"url"},"children":[{"id":"e5caae1327cf","title":"7个基本数据类型","parent":"79ed9bf78722","children":[{"id":"f6eaaacfaa39","title":"Boolean","parent":"e5caae1327cf","children":[]},{"id":"4cf2ba2ba4e0","title":"String","parent":"e5caae1327cf","children":[{"id":"81478bf37070","title":"字符串是否有最大长度？","children":[{"id":"b5157a137764","title":"有最大长度是 <b>2^53 - 1</b>","children":[],"parent":"81478bf37070"},{"id":"e88d36f5d459","title":"但是这个所谓最大长度，并不完全是你理解中的字符数。因为 JavaScript 中的String类型存储的方式是 UTF16格式的，所以 String 的最大长度指的是保存为UTF16格式时候的最大程度。","parent":"81478bf37070","children":[],"summaries":[]}],"parent":"4cf2ba2ba4e0"}],"collapsed":true},{"id":"18e7ec5b4e32","title":"Number","parent":"e5caae1327cf","children":[{"id":"c2cd0abb3c0d","title":"为什么在 JavaScript 中，0.1+0.2 不能 =0.3？","children":[{"id":"0aadb6793123","title":"计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失，当这些丢失精度的二进制转换成十进制就造成上面的错误了。","children":[],"parent":"c2cd0abb3c0d"},{"id":"11c888a75c80","title":"另外，值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分，“忘记检测除以 -0，而得到负无穷大”的情况经常会导致错误，而区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity。","children":[],"parent":"c2cd0abb3c0d"},{"id":"a58918396db2","title":"正确的比较方法","children":[{"id":"a48402e9f6be","title":"Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON","children":[],"parent":"a58918396db2","note":"EPSILON 是最小精度值"}],"parent":"c2cd0abb3c0d"}],"parent":"18e7ec5b4e32","collapsed":false}],"collapsed":true},{"id":"04527cfce213","title":"Null","parent":"e5caae1327cf","children":[{"id":"0452d38129e2","title":"Null类型的值只有一个 null，表示一个变量定义了但是值为空。null是关键字，可放心使用","parent":"04527cfce213","children":[]}],"collapsed":true},{"id":"0bbe9b52ca3a","title":"Undefined","parent":"e5caae1327cf","children":[{"id":"edb8048df763","title":"为什么有的编程规范要求用 void 0 代替 undefined？","parent":"0bbe9b52ca3a","children":[{"id":"1c08d2f1efcd","title":"Undefined类型的值只有一个 undefined。","parent":"edb8048df763","children":[]},{"id":"81b69bd4bed7","title":"任何一个变量未赋值前值都为 undefined，表示一个变量定义了但是未赋值。一般我们使用全局变量 undefined 表示","parent":"edb8048df763","children":[]},{"id":"c3b0eb864feb","title":"由于 undefined 是个变量，是可以被修改的，所以我们一般使用 void 0 的返回值（void 运算符 可以对给定的表达式进行求值，然后返回 undefined）来代替 undefined 变量。","parent":"edb8048df763","children":[]}]}],"collapsed":true},{"id":"a78b1fb4a652","title":"Object","parent":"e5caae1327cf","children":[{"id":"dd9b39c4e56a","title":"面向对象","children":[{"id":"ca4eb80405ac","title":"最为成功的流派是使用“类”的方式来描述对象，这诞生了诸如 C++、Java 等流行的编程语言。而 JavaScript 早年却选择了一个更为冷门的方式：原型。","children":[],"parent":"dd9b39c4e56a"},{"id":"8b7a358ef963","title":"对象的本质特征","children":[{"id":"5569d72a6594","title":"对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。<br>","children":[{"id":"ab98022fcbcd","title":"通过内存地址区分","children":[],"parent":"5569d72a6594","note":"```\nvar o1 = { a: 1 };\nvar o2 = { a: 1 };\nconsole.log(o1 == o2); // false\n```"}],"parent":"8b7a358ef963"},{"id":"33fc06e45c4b","title":"对象有状态：对象具有状态，同一对象可能处于不同状态之下。<br>","children":[{"id":"90368d2db006","title":"也就是对象的属性","parent":"33fc06e45c4b","children":[]}],"parent":"8b7a358ef963"},{"id":"800a9ef96ffc","title":"对象具有行为：即对象的状态，可能因为它的行为产生变迁。","children":[{"id":"5046b2a32026","title":"也就是对象的方法","parent":"800a9ef96ffc","children":[],"note":"JavaScript 中的行为和状态都能用属性来抽象；如下：\n\n```\nvar o = { \n        d: 1,\n        f() {\n            console.log(this.d);\n        }    \n    };\n```\n    "}],"parent":"8b7a358ef963"}],"parent":"dd9b39c4e56a"}],"parent":"a78b1fb4a652","collapsed":false},{"id":"3e2f57495040","title":"JavaScript中的面向对象","children":[{"id":"fc1a1e6c0be2","title":"实现了上面的“对象的本质特征”","parent":"3e2f57495040","children":[]},{"id":"2fed9bf90bac","title":"JavaScript 中对象独有的特色是：对象具有高度的动态性，这是因为 JavaScript 赋予了使用者在运行时为对象添改状态和行为的能力。","parent":"3e2f57495040","children":[],"note":"比如，JavaScript 允许运行时向对象添加属性"},{"id":"ca6470d9a92d","title":"为了提高抽象能力，JavaScript 的属性被设计成比别的语言更加复杂的形式，它提供了<b>数据属性和访问器属性（getter/setter）两类</b>。<br>","children":[{"id":"f072e20fcc15","title":"数据属性","children":[{"id":"ad6ac9ee117b","title":"四个特征","children":[{"id":"b9f4e4b508df","title":"value：就是属性的值。<br>","parent":"ad6ac9ee117b","children":[]},{"id":"f94d4a3ac042","title":"writable：决定属性能否被赋值。<br>","parent":"ad6ac9ee117b","children":[]},{"id":"c922e2cbb728","title":"enumerable：决定 for in 能否枚举该属性。<br>","parent":"ad6ac9ee117b","children":[]},{"id":"635141213765","title":"configurable：决定该属性能否被删除或者改变特征值。<br>","parent":"ad6ac9ee117b","children":[],"note":""}],"parent":"f072e20fcc15","note":"在大多数情况下，我们只关心数据属性的值即可。"},{"id":"a1ad8ad52187","title":"获取属性特征：内置函数 Object.getOwnPropertyDescripter 来查看数据属性","parent":"f072e20fcc15","children":[],"note":"```\nvar o = { a: 1 };\no.b = 2;\n//a和b皆为数据属性\n\n// {value: 1, writable: true, enumerable: true, configurable: true}\nObject.getOwnPropertyDescriptor(o,&quot;a&quot;) \n\t\n// {value: 2, writable: true, enumerable: true, configurable: true}\nObject.getOwnPropertyDescriptor(o,&quot;b&quot;) \n```"},{"id":"45f8e7307e7b","title":"设置属性的特征：可以使用 Object.defineProperty","children":[],"parent":"f072e20fcc15","note":"```\n    var o = { a: 1 };\n    Object.defineProperty(o, &quot;b&quot;, {value: 2, writable: false, enumerable: false, configurable: true});\n    //a和b都是数据属性，但特征值变化了\n    Object.getOwnPropertyDescriptor(o,&quot;a&quot;); // {value: 1, writable: true, enumerable: true, configurable: true}\n    Object.getOwnPropertyDescriptor(o,&quot;b&quot;); // {value: 2, writable: false, enumerable: false, configurable: true}\n    o.b = 3;\n    console.log(o.b); // 2\n```\n\n这里我们使用了 `Object.defineProperty` 来定义属性，这样定义属性可以改变属性的 writable 和 enumerable。我们同样用 Object.getOwnPropertyDescriptor 来查看，发现确实改变了 writable 和 enumerable 特征。因为 writable 特征为 false，所以我们重新对 b 赋值，b 的值不会发生变化。"}],"parent":"ca6470d9a92d"},{"id":"91b7f9b67368","title":"访问器属性（getter/setter）","children":[{"id":"f4927cf9b131","title":"定义/创建访问器属性","parent":"91b7f9b67368","children":[],"note":"```\nvar o = { get a() { return 1 } };\n\nconsole.log(o.a); // 1\n```"},{"id":"c5a3df36e1c8","title":"四个特征","parent":"91b7f9b67368","children":[{"id":"217d0069f828","title":"getter：函数或 undefined，在取属性值时被调用。<br>","children":[],"parent":"c5a3df36e1c8"},{"id":"f89ff68d7ab4","title":"setter：函数或 undefined，在设置属性值时被调用。","children":[],"parent":"c5a3df36e1c8"},{"id":"a49d373ee55c","title":"enumerable：决定 for in 能否枚举该属性。","children":[],"parent":"c5a3df36e1c8"},{"id":"814d876da8d7","title":"configurable：决定该属性能否被删除或者改变特征值。","children":[],"parent":"c5a3df36e1c8"}],"note":"访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。"}],"parent":"ca6470d9a92d","icons":[]}],"parent":"3e2f57495040","summaries":[{"summary":true,"id":"91167283f2e6","title":"实际上 JavaScript 对象的运行时是一个“属性的集合”，属性以字符串或者 Symbol 为 key，以数据属性特征值或者访问器属性特征值为 value。","range":2,"parent":"ca6470d9a92d","children":[],"part":"right"}],"collapsed":false}],"parent":"a78b1fb4a652","collapsed":true},{"id":"e13c9bb40070","title":"JavaScript需要模拟类吗？<br>（JavaScript的原型）","parent":"a78b1fb4a652","children":[{"id":"2fe8ac185b98","title":"实现面向对象的方式","children":[{"id":"9957dd298524","title":"JavaScript 本身就是面向对象的，它并不需要模拟，只是它实现面向对象的方式和主流的流派不太一样。那些“模拟面向对象”，实际上做的事情就是“模拟基于类的面向对象”。所以，JavaScript 创始人 Brendan Eich 在“原型运行时”的基础上引入了 new、this 等语言特性，使之“看起来语法更像 Java”，而 Java 正是基于类的面向对象的代表语言之一。庆幸的是，从 ES6 开始，JavaScript 提供了 class 关键字来定义类，尽管，这样的方案仍然是基于原型运行时系统的模拟，但是它修正了之前的一些常见的“坑”，统一了社区的方案。实际上，我认为“基于类”并非面向对象的唯一形态，如果我们把视线从“类”移开，Brendan 当年选择的原型系统，就是一个非常优秀的抽象对象的形式。","parent":"2fe8ac185b98","children":[]},{"id":"6251cc89af4a","title":"基于类的面向对象语言（如C++，Java）","children":[{"id":"e1c2927f71a0","title":"在这类语言中，总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。","parent":"6251cc89af4a","children":[]}],"parent":"2fe8ac185b98"},{"id":"838335010f74","title":"基于原型的面向对象语言（如JavaScript）","parent":"2fe8ac185b98","children":[{"id":"9ef7aa68f7eb","title":"更关注对象的行为，然后将其划分到与之相似的对象上，而不划分到某个类上，于是基于原型的面向对象系统通过“复制”的方式来创建新对象，而非通过类来创建新对象。<br>","children":[],"parent":"838335010f74","note":"比如“照猫画虎”，将虎划分到猫这个对象上，而不是划分到猫科豹属豹亚种这个类。"}]}],"parent":"e13c9bb40070"},{"id":"9ffc676da0cb","title":"什么是原型？","children":[{"id":"af9abf5fdaa1","title":"中文中有个成语叫做“照猫画虎”，这里的猫看起来就是虎的原型。","parent":"9ffc676da0cb","children":[]}],"parent":"e13c9bb40070","note":""},{"id":"99abeb5aba48","title":"原型系统的“复制操作”有两种实现思路：","parent":"e13c9bb40070","children":[{"id":"21c919b8d5a1","title":"<span style=\"font-size: inherit;\">1、一个是并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用（<b><font color=\"#0076b3\">JavaScript采用的方式</font></b>）</span><br>","children":[],"parent":"99abeb5aba48"},{"id":"58e5ae34b626","title":"<span style=\"font-size: inherit;\">2、另一个是切实地复制对象，从此两个对象再无关联。</span><br>","children":[],"parent":"99abeb5aba48"}]},{"id":"f39fdd0db40c","title":"JavaScript中的原型","parent":"e13c9bb40070","children":[{"id":"883881cd6cd7","title":"简单的原型特征就两点","parent":"f39fdd0db40c","children":[{"id":"40af69626a45","title":"1、如果所有对象都有私有字段 prototype ，就是对象的原型；","children":[],"parent":"883881cd6cd7"},{"id":"2ac93edcb7c9","title":"2、读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。","children":[],"parent":"883881cd6cd7"}]},{"id":"956035f97e40","title":"ES6提供的创建/操作原型","parent":"f39fdd0db40c","children":[{"id":"137a13334cc0","title":"Object.create 根据指定的原型创建新对象，原型可以是 null;","children":[],"parent":"956035f97e40","note":"用原型来抽象猫和虎的例子\n\n```\nvar cat = {\n    say(){\n        console.log(&quot;meow~&quot;);\n    },\n    jump(){\n        console.log(&quot;jump&quot;);\n    }\n}\n\nvar tiger = Object.create(cat,  {\n    say:{\n        writable:true,\n        configurable:true,\n        enumerable:true,\n        value:function(){\n            console.log(&quot;roar!&quot;);\n        }\n    }\n})\n\n\nvar anotherCat = Object.create(cat);\n\nanotherCat.say();\n\nvar anotherTiger = Object.create(tiger);\n\nanotherTiger.say();\n\n```"},{"id":"2453a34a2a3b","title":"Object.getPrototypeOf 获得一个对象的原型；","parent":"956035f97e40","children":[]},{"id":"ee2a5a635858","title":"Object.setPrototypeOf 设置一个对象的原型。","parent":"956035f97e40","children":[]}]},{"id":"e417efee575d","title":"早期版本中的类与原型","children":[{"id":"cbb95f76d570","title":"ES3及之前","parent":"e417efee575d","children":[{"id":"5201307601c7","title":"“类”的定义会有一个私有属性 [[class]]，语言标准为内置类型诸如 Number、String、Date 等指定了[[class]]属性，以表示它们的类。语言使用者唯一可以访问[[class]]属性的方式是 Object.prototype.toString。","children":[{"id":"b640a380f528","title":"以下代码展示了所有具有内置 class 属性的对象<br>","parent":"5201307601c7","children":[],"image":{"w":535,"h":307,"url":"http://cdn.processon.com/5e4f4927e4b0ad256cf80ddf?e=1582257976&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:uJlIj4mTSc3bh7zBqd3a-4a43qc="}}],"parent":"cbb95f76d570"},{"id":"4f7dd31fc770","title":"new","children":[{"id":"df88c2c9fded","title":"new 试图让函数对象在语法上跟类变得相似，但是，它客观上提供了两种方式，一是在构造器中添加属性，二是在构造器的 prototype 属性上添加属性。","children":[{"id":"1fd3143c0def","title":"下面代码展示了用构造器模拟类的两种方法:","parent":"df88c2c9fded","children":[],"note":"```\nfunction c1(){\n    this.p1 = 1;\n    this.p2 = function(){\n        console.log(this.p1);\n    }\n} \nvar o1 = new c1;\no1.p2(); // 1\n\n\n\nfunction c2(){\n}\nc2.prototype.p1 = 1;\nc2.prototype.p2 = function(){\n    console.log(this.p1);\n}\n\nvar o2 = new c2;\no2.p2(); // 1\n```\n\n第一种方法是直接在构造器中修改 this，给 this 添加属性。\n\n第二种方法是修改构造器的 prototype 属性指向的对象，它是从这个构造器构造出来的所有对象的原型。"},{"id":"94b68a169633","title":"没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定[[prototype]]的方法（当时的 mozilla 提供了私有属性 __proto__，但是多数环境并不支持）","children":[],"parent":"df88c2c9fded"}],"parent":"4f7dd31fc770"}],"parent":"cbb95f76d570"}]},{"id":"66252a497256","title":"ES5","children":[{"id":"48578ad19d00","title":"在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为","children":[{"id":"6439eb099441","title":"这里创建了一个新对象，并且给它唯一的一个属性 Symbol.toStringTag，我们用字符串加法触发了 Object.prototype.toString 的调用，发现这个属性最终对 Object.prototype.toString 的结果产生了影响。<br>","children":[],"parent":"48578ad19d00","image":{"w":330,"h":70,"url":"http://cdn.processon.com/5e4f4a4be4b0beec08deed7c?e=1582258267&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:uRiYxsnFwfGjhZEKVWdG10yOHyk="}}],"parent":"66252a497256"}],"parent":"e417efee575d"},{"id":"71e70c367602","title":"ES6","children":[{"id":"5c4428e94870","title":"ES6 中引入了 class 关键字，并且在标准中删除了所有[[class]]相关的私有属性描述，类的概念正式从属性升级成语言的基础设施，从此，基于类的编程方式成为了 JavaScript 的官方编程范式。","children":[],"parent":"71e70c367602"},{"id":"657eadb7b7b1","title":"基本写法","children":[{"id":"26404d434aef","title":"类的写法实际上也是由原型运行时来承载的，逻辑上 JavaScript 认为每个类是有共同原型的一组对象，类中定义的方法和属性则会被写在原型对象之上。","parent":"657eadb7b7b1","children":[]}],"parent":"71e70c367602","note":"```\n\nclass Rectangle {\n  // constructor 里面定义类的属性\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n  // Getter\n  get area() {\n    return this.calcArea();\n  }\n  // Setter\n\n  // Method\n  calcArea() {\n    return this.height * this.width;\n  }\n}\n```"},{"id":"75bd0905f096","title":"类的继承","parent":"71e70c367602","children":[],"note":"```\n\nclass Animal { \n  constructor(name) {\n    this.name = name;\n  }\n  \n  speak() {\n    console.log(this.name + &#39; makes a noise.&#39;);\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name) {\n    super(name); // call the super class constructor and pass in the name parameter\n  }\n\n  speak() {\n    console.log(this.name + &#39; barks.&#39;);\n  }\n}\n\nlet d = new Dog(&#39;Mitzie&#39;);\nd.speak(); // Mitzie barks.\n```"}],"parent":"e417efee575d"}],"parent":"f39fdd0db40c"}]}],"collapsed":true},{"id":"9c7819265eca","title":"JavaScript 中的对象分类","parent":"a78b1fb4a652","children":[{"id":"6f3b8e465475","title":"宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。","parent":"9c7819265eca","children":[{"id":"8197a34ae1a8","title":"window","children":[],"parent":"6f3b8e465475"},{"id":"cf8b5916de51","title":"document","children":[],"parent":"6f3b8e465475"}]},{"id":"fd40ff0d23f0","title":"内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。","parent":"9c7819265eca","children":[{"id":"0cca3db1ac08","title":"固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。（150+ 个）<br>","parent":"fd40ff0d23f0","children":[{"id":"73a48640d635","title":"三个值：Infinity、NaN、undefined。","parent":"0cca3db1ac08","children":[]},{"id":"5545e6bd7568","title":"九个函数","parent":"0cca3db1ac08","children":[],"note":"eval\nisFinite\nisNaN\nparseFloat\nparseInt\ndecodeURI\ndecodeURIComponent\nencodeURI\nencodeURIComponent"},{"id":"2a320df7aa74","title":"一些构造器：原生对象内容","children":[],"parent":"0cca3db1ac08"},{"id":"938851f0817e","title":"四个用于当作命名空间的对象：Atomics，JSON，Math，Reflect","parent":"0cca3db1ac08","children":[]}]},{"id":"78db141a97ab","title":"原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。","children":[{"id":"227ea00a65a7","title":"PS：几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。","children":[],"parent":"78db141a97ab","image":{"w":447,"url":"http://cdn.processon.com/5e4f7f9ce4b0c037b5f7d7ea?e=1582271916&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:viX0KgMQLMaZJFahhZZO4s1Wlbk=","h":169}}],"parent":"fd40ff0d23f0"},{"id":"3a0b0afc363e","title":"普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。","children":[],"parent":"fd40ff0d23f0"}]},{"id":"159bc6efd078","title":"特殊行为的对象","children":[{"id":"85fa7a32de8b","title":"Array：Array 的 length 属性根据最大的下标自动发生变化。","children":[],"parent":"159bc6efd078"},{"id":"cf4eaf1ef971","title":"Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。","children":[],"parent":"159bc6efd078"},{"id":"d041f2270ff3","title":"String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。<br>","children":[],"parent":"159bc6efd078"},{"id":"4db70d48d57f","title":"Arguments：arguments 的非负整数型下标属性跟对应的变量联动。","children":[],"parent":"159bc6efd078"},{"id":"6eaf11ed3fd4","title":"模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。","children":[],"parent":"159bc6efd078"},{"id":"cfb3e6fa8002","title":"类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。","children":[],"parent":"159bc6efd078"},{"id":"feaca935e825","title":"bind 后的 function：跟原来的函数相关联。","children":[],"parent":"159bc6efd078"}],"parent":"9c7819265eca"}],"collapsed":true}],"collapsed":false},{"id":"5d2604150b21","title":"Symbol（ES6新增）","parent":"e5caae1327cf","children":[{"id":"d7b542172ffa","title":"作用：保证对象的属性名唯一","children":[],"parent":"5d2604150b21"},{"id":"c3ec9d7080d8","title":"创建Symbol变量：let s = Symbol();","children":[{"id":"556d1b7f26c7","title":"Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述， 主要是为了在控制台显示，或者转为字符串时，比较容易区分。 例子如图。","parent":"c3ec9d7080d8","children":[],"note":"```javascript\nlet s1 = Symbol(&#39;foo&#39;);\nlet s2 = Symbol(&#39;bar&#39;);\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // &quot;Symbol(foo)&quot;\ns2.toString() // &quot;Symbol(bar)&quot;\n```\n\n上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。\n\n如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。\n\n```\nconst obj = {\n  toString() {\n    return &#39;abc&#39;;\n  }\n};\nconst sym = Symbol(obj);\nsym // Symbol(abc)\n```\n\n&gt; 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的（虽然描述看起来是相同的）。\n\n```\nlet s = Symbol(&#39;aaa&#39;);\nlet s1 = Symbol(&#39;aaa&#39;);\nconsole.log(s,s1,s==s1); // Symbol(aaa) Symbol(aaa) false\n```\n\n\n\n\n\n\n\n\n\n\n\n\n"}],"parent":"5d2604150b21","note":"注意：Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。"}],"collapsed":true}],"collapsed":true},{"id":"d0124eeb7a49","title":"为什么给对象添加的方法能用在基本类型上？","children":[{"id":"9a0919a5db77","title":"我们必须认识到 3 与 new Number(3) 是完全不同的值，它们一个是 Number 类型， 一个是对象类型。","children":[],"parent":"d0124eeb7a49"},{"id":"0e41728a4a6f","title":"Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。","children":[],"parent":"d0124eeb7a49"},{"id":"ea29c9b37d1e","title":"Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。","children":[],"parent":"d0124eeb7a49"},{"id":"963855457840","title":"所以问题的答案是： 运算符提供了装箱操作，它会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。","children":[{"id":"f6aec17cd777","title":"装箱转换和拆箱转换","parent":"963855457840","children":[{"id":"a95c5e9705a1","title":"装箱","parent":"f6aec17cd777","children":[],"note":"每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对应的对象。\n\n&lt;br&gt;\n\n前文提到，全局的 Symbol 函数无法使用 new 来调用，但我们仍可以利用装箱机制来得到一个 Symbol 对象，我们可以利用一个函数的 call 方法来强迫产生装箱。\n\n```\nvar symbolObject = (function(){ return this; }).call(Symbol(&quot;a&quot;));\n\n    console.log(typeof symbolObject); //object\n    console.log(symbolObject instanceof Symbol); //true\n    console.log(symbolObject.constructor == Symbol); //true\n```\n\n我们定义一个函数，函数里面只有 return this，然后我们调用函数的 call 方法到一个 Symbol 类型的值上，这样就会产生一个 symbolObject。\n\n&lt;br&gt;\n\n我们可以用 console.log 看一下这个东西的 type of，它的值是 object，我们使用 symbolObject instanceof 可以看到，它是 Symbol 这个类的实例，我们找它的 constructor 也是等于 Symbol 的，所以我们无论从哪个角度看，它都是 Symbol 装箱过的对象。\n\n&lt;br&gt;\n\n装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，我们应该尽量避免对基本类型做装箱转换。\n\n&lt;br&gt;\n\n使用内置的 Object 函数，我们可以在 JavaScript 代码中显式调用装箱能力。\n\n```\nvar symbolObject = Object(Symbol(&quot;a&quot;));\n\n    console.log(typeof symbolObject); //object\n    console.log(symbolObject instanceof Symbol); //true\n    console.log(symbolObject.constructor == Symbol); //true\n```\n\n每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取：\n\n```\nvar symbolObject = Object(Symbol(&quot;a&quot;));\n\n    console.log(Object.prototype.toString.call(symbolObject)); //[object Symbol]\n```\n\n在 JavaScript 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceof 更加准确。\n\n"},{"id":"186cea0c8e9d","title":"拆箱","parent":"f6aec17cd777","children":[],"note":"拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型。如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。\n\n&lt;br&gt;\n\n如下面的例子：\n\n```\nvar o = {\n    valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return {}},\n    toString : () =&gt; {console.log(&quot;toString&quot;); return {}}\n}\n\no * 2\n// valueOf\n// toString\n// TypeError\n```\n\n我们定义了一个对象 o，o 有 valueOf 和 toString 两个方法，这两个方法都返回一个对象，然后我们进行 o*2 这个运算的时候（一个对象乘以2，那么js会想把o转换成Number基本类型，会调用valueOf，并期望返回一个基本类型，但是返回的却是一个对象。。），你会看见先执行了 valueOf，接下来是 toString，最后抛出了一个 TypeError，这就说明了这个拆箱转换失败了。\n\n&lt;br&gt;\n\n如果将valueOf的返回值改为任意基本类型就会拆箱成功，如：\n\n```\nvar o = {\n    valueOf : () =&gt; {console.log(&quot;valueOf&quot;); return undefined},\n    toString : () =&gt; {console.log(&quot;toString&quot;); return {}}\n}\n```\n\n&gt; valueOf，和toString的执行顺序默认是valueOf先，然后是toString。"}]}],"parent":"d0124eeb7a49","note":"```\nlet num = 123;\nconsole.log(num.toString()); //  num被悄悄转换成临时对象 new Number(123)\nconsole.log(&quot;abc&quot;.charAt(0)); // &#39;abc&#39; 字符串被悄悄转换成临时对象 new String(&#39;abc&#39;)\n```"}],"parent":"79ed9bf78722","collapsed":true},{"id":"288ddedaa293","title":"类型判断","children":[{"id":"fa6eab67af71","title":"typeof 类型判断准确吗？","children":[{"id":"74e659cf9b0d","title":"事实上，“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JavaScript 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。<br><br>在表格中，多数项是对应的，但是请注意 object——Null 和 function——Object 是特例，我们理解类型的时候需要特别注意这个区别。","image":{"w":261,"url":"http://cdn.processon.com/5e4e7949e4b0834dd83fbb6c?e=1582204761&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:LzbpBUM9Yr85lyq99wOVQK-96eU=","h":241},"parent":"fa6eab67af71","children":[]}],"parent":"288ddedaa293"}],"parent":"79ed9bf78722","collapsed":true}],"parent":"root","collapsed":false},{"id":"ec4354e75254","title":"文法<br>","parent":"root","children":[{"id":"f0d0637568ef","title":"词法","parent":"ec4354e75254","children":[{"id":"819b8fbc615f","title":"空白字符","children":[{"id":"26b0887ba7db","title":"空白符不止空格，但是很多公司的编码规范要求 JavaScript 源代码控制在 ASCII 范围内，那么，就只有&lt;TAB&gt; &lt;VT&gt; &lt;FF&gt; &lt;SP&gt; &lt;NBSP&gt;五种空白可用了。","children":[],"parent":"819b8fbc615f","note":"- `&lt;HT&gt;`(或称`&lt;TAB&gt;`) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \\t 。\n- `&lt;VT&gt;`是 U+000B，也就是垂直方向的 TAB 符 \\v，这个字符在键盘上很难打出来，所以很少用到。\n- `&lt;FF&gt;`是 U+000C，Form Feed，分页符，字符串直接量中写作 \\f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。\n- `&lt;SP&gt;`是 U+0020，就是最普通的空格了。\n- `&lt;NBSP&gt;`是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript 编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 &nbsp; 最后生成的就是它了。\n- `&lt;ZWNBSP&gt;`(旧称`&lt;BOM&gt;`) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF 格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。"},{"id":"54d001c38424","title":"零宽度字符","parent":"819b8fbc615f","children":[{"id":"eb63847f1ead","title":"参考文档","children":[{"id":"9d873b217597","title":"JavaScript零宽字符","link":{"title":"JavaScript零宽字符","value":"https://juejin.im/post/5e4b655de51d45271515563a","type":"url"},"children":[],"parent":"eb63847f1ead"},{"id":"68667995d544","title":"零宽度字符：和谐？屏蔽？不存在的<br>","link":{"title":"零宽度字符：和谐？屏蔽？不存在的","value":"https://juejin.im/post/5b87a6e26fb9a019b953ee8b","type":"url"},"parent":"eb63847f1ead","children":[]}],"parent":"54d001c38424"},{"id":"66a1be45c298","title":"使用场景","children":[{"id":"b125b1916147","title":"加密解密","children":[],"parent":"66a1be45c298"},{"id":"ab95d33a61d5","title":"隐形水印","children":[],"parent":"66a1be45c298"},{"id":"18388f6549ad","title":"敏感词分割","parent":"66a1be45c298","children":[]}],"parent":"54d001c38424"}]}],"parent":"f0d0637568ef"},{"id":"257d5cd05da8","title":"换行符","children":[{"id":"6c2691895834","title":"&lt;LF&gt;：最正常换行符，在字符串中的\\n<br>","parent":"257d5cd05da8","children":[]},{"id":"7beef633b041","title":"&lt;CR&gt;：这个字符真正意义上的“回车”，在字符串中是\\r，在一部分 Windows 风格文本编辑器中，换行是两个字符\\r\\n。<br>","children":[],"parent":"257d5cd05da8"},{"id":"3dc9219b34c7","title":"&lt;LS&gt;： Unicode 中的行分隔符<br>","children":[],"parent":"257d5cd05da8"},{"id":"6b73b3dc4f38","title":"&lt;PS&gt;：Unicode 中的段落分隔符。","children":[],"parent":"257d5cd05da8"}],"parent":"f0d0637568ef","note":"大部分换行符在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。"},{"id":"a3a8d76909aa","title":"注释","children":[{"id":"8af9cb34a6ac","title":"分为单行注释和多行注释","children":[],"parent":"a3a8d76909aa"}],"parent":"f0d0637568ef","note":"我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。"},{"id":"caa481b7fc4b","title":"词 token","children":[{"id":"15b2894103da","title":"标识符","children":[{"id":"7a109903499d","title":"变量，关键字（break,case,const,debugger...）","children":[],"parent":"15b2894103da","note":"保留关键字：\n\n```\nenum\n\nimplements package protected interface private public\n\nnull, true, false\n```"}],"parent":"caa481b7fc4b"},{"id":"e62016236b25","title":"符号","children":[{"id":"367b0f259b3f","title":"{} + - 等","parent":"e62016236b25","children":[]}],"parent":"caa481b7fc4b"},{"id":"cc33b86624eb","title":"数字","children":[{"id":"13f3d2d042e8","title":"123","children":[{"id":"d693ec0751fc","title":"支持四种写法","children":[{"id":"9f5251d817e3","title":"十进制","parent":"d693ec0751fc","children":[{"id":"514ccbcdfe9b","title":"下面十进制的写法都是合理的： .01&nbsp; 12.&nbsp; 12.01","children":[],"parent":"9f5251d817e3"},{"id":"b7d259eb777d","title":"<br>12.toString() 合法吗？","children":[],"parent":"9f5251d817e3","note":"不合法。\n\n这时候12. 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写：\n\n```\n12 .toString()\n```"},{"id":"2cc4951fdd57","title":"支持科学计数法","parent":"9f5251d817e3","children":[{"id":"134b54308492","title":"10.24E+2&nbsp; 10.24e-2&nbsp; 10.24e2","children":[],"parent":"2cc4951fdd57"}]}]},{"id":"c3a53bb9804c","title":"二进制","parent":"d693ec0751fc","children":[{"id":"f67b7405b5bb","title":"0b10000","parent":"c3a53bb9804c","children":[]}]},{"id":"9e341411ae9c","title":"八进制","parent":"d693ec0751fc","children":[{"id":"34526f5f0dec","title":"0o73","parent":"9e341411ae9c","children":[]}]},{"id":"a6f7b1c1804c","title":"十六进制","parent":"d693ec0751fc","children":[{"id":"248f65a6ff5d","title":"0xFA","parent":"a6f7b1c1804c","children":[]}]}],"parent":"13f3d2d042e8","collapsed":false}],"parent":"cc33b86624eb","collapsed":true}],"parent":"caa481b7fc4b"},{"id":"c98730396192","title":"字符串","children":[{"id":"1e1887d223c6","title":"'abc' \"abc\"","children":[{"id":"d24fcb407849","title":"转义字符（' \" \\&nbsp; b f n r t v）","children":[],"parent":"1e1887d223c6"}],"parent":"c98730396192"}],"parent":"caa481b7fc4b"},{"id":"08227e77d8c4","title":"字符串模板","children":[{"id":"531b97fe3004","title":"`${abc}`","parent":"08227e77d8c4","children":[{"id":"da5cf608555b","title":"模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：<br>","parent":"531b97fe3004","children":[],"note":"```\nfunction f(){\n    console.log(arguments);\n}\n\nvar a = &quot;abc&quot;\nvar b = &quot;def&quot;\nf`wo${a}shi${b}!`; // [[&quot;wo&quot;, &quot;shi&quot;,&quot;!&quot;], abc, def]\n```\n\n可以看到字符串部分和字符串模板部分被分开传入函数做为参数。"}]}],"parent":"caa481b7fc4b"}],"parent":"f0d0637568ef"}],"note":"语言的最小语义单元：token","collapsed":true},{"id":"131ae7ff1ebf","title":"语法","parent":"ec4354e75254","children":[{"id":"d3f610068e15","title":"要不要写分号？<br>","children":[{"id":"b5558a083066","title":"自动插入分号的规则","parent":"d3f610068e15","children":[{"id":"f314c9586e2a","title":"1、要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号。","parent":"b5558a083066","children":[],"note":"```js\nlet a = 1\nvoid function(a){\n    console.log(a);\n}(a);\n```\n\n在这个例子中，第一行的结尾处有换行符，接下来 void 关键字接在 1 之后是不合法的，这命中了我们的第一条规则，因此会在 void 前插入换行符。"},{"id":"f7b38fe53a74","title":"2、有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。","parent":"b5558a083066","children":[{"id":"1dbb28f3e59a","title":"no LineTerminator here 规则","children":[{"id":"bfebe1bef95b","title":"带标签的continue语句，不能在continue后面插入换行","parent":"1dbb28f3e59a","children":[],"note":"```\n\nouter:for(var j = 0; j &lt; 10; j++)\n    for(var i = 0; i &lt; j; i++)\n        continue /*no LineTerminator here*/ outter\n```"},{"id":"c143a0a3ce99","title":"带标签的break语句，不能再break后插入换行","children":[],"parent":"1dbb28f3e59a","note":"```\nouter:for(var j = 0; j &lt; 10; j++)\n    for(var i = 0; i &lt; j; i++)\n        break /*no LineTerminator here*/ outter\n```"},{"id":"eb99a7fe94c0","title":"return后不能插入换行","parent":"1dbb28f3e59a","children":[],"note":"```\nfunction f(){\n    return /*no LineTerminator here*/1;\n}\n```"},{"id":"9a69bbfece01","title":"后自增，后自减运算符前不能插入换行","children":[],"parent":"1dbb28f3e59a","note":"```\ni/*no LineTerminator here*/++\ni/*no LineTerminator here*/--\n```"},{"id":"b1ed3bd67d3c","title":"throw和Exception之间不能插入换行","children":[],"parent":"1dbb28f3e59a","note":"```\nthrow/*no LineTerminator here*/new Exception(&quot;error&quot;)\n```"},{"id":"4e88d3611278","title":"凡async关键字，后面都不能插入换行","children":[],"parent":"1dbb28f3e59a","note":"```\nasync/*no LineTerminator here*/function f(){\n\n}\nconst f = async/*no LineTerminator here*/x =&gt; x*x\n```"},{"id":"1a11217a7483","title":"箭头函数的箭头前，也不能插入换行","children":[],"parent":"1dbb28f3e59a","note":"```\nconst f = x/*no LineTerminator here*/=&gt; x*x\n```"},{"id":"ea2b524d1357","title":"yield之后，不能插入换行","children":[],"parent":"1dbb28f3e59a","note":"```\nfunction *g(){\n    var i = 0;\n    while(true)\n        yield/*no LineTerminator here*/i++;\n}\n```"}],"parent":"f7b38fe53a74"},{"id":"dd43b562a83a","title":"实际上，no LineTerminator here 规则的存在，多数情况是为了保证自动插入分号行为是符合预期的，但是令人遗憾的是，JavaScript 在设计的最初，遗漏了一些重要的情况，所以有一些不符合预期的情况出现","children":[{"id":"8e97f2ccb046","title":"以括号开头的语句","children":[],"parent":"dd43b562a83a","note":"```\n(function(a){\n    console.log(a);\n})()/*这里没有被自动插入分号*/\n(function(a){\n    console.log(a);\n})()\n```\n这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。"},{"id":"943e95584635","title":"以数组开头的语句","children":[],"parent":"dd43b562a83a","note":"```\nvar a = [[]]/*这里没有被自动插入分号*/\n[3, 2, 1, 0].forEach(e =&gt; console.log(e))\n```\n这段代码本意是一个变量 a 赋值，然后对一个数组执行 forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，我这个例子展示的情况，甚至不会抛出错误，这对于代码排查问题是个噩梦。\n"},{"id":"0da736eba514","title":"以正则表达式开头的语句","children":[],"parent":"dd43b562a83a","note":"```\nvar x = 1, g = {test:()=&gt;0}, b = 1/*这里没有被自动插入分号*/\n/(a)/g.test(&quot;abc&quot;)\nconsole.log(RegExp.$1)\n```\n\n这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母 a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。\n\n当然，这种情况比较少见。"},{"id":"302784861230","title":"以 Template 开头的语句","parent":"dd43b562a83a","children":[],"note":"```\nvar f = function(){\n  return &quot;&quot;;\n}\nvar g = f/*这里没有被自动插入分号*/\n`Template`.match(/(a)/);\nconsole.log(RegExp.$1)\n```\n\n这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。\n\n当然，这种情况更少见了。"}],"parent":"f7b38fe53a74"}],"summaries":[],"note":"```js\nvar a = 1, b = 1, c = 1;\na\n++\nb\n++\nc\n```\n\n这也是个著名的例子，我们看第二行的 a 之后，有换行符，后面遇到了 ++ 运算符，a 后面跟 ++ 是合法的语法，但是我们看看 JavaScript 标准定义中，有[no LineTerminator here]这个字样,于是，这里 a 的后面就要插入一个分号了。所以这段代码最终的结果，b 和 c 都变成了 2，而 a 还是 1。"},{"id":"834a6fcc95ea","title":"3、源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号。","summaries":[],"children":[],"parent":"b5558a083066"}]}],"parent":"131ae7ff1ebf","collapsed":true},{"id":"0d8ef2015e89","title":"执行规则","parent":"131ae7ff1ebf","children":[{"id":"a00498785e78","title":"脚本与模块","parent":"0d8ef2015e89","children":[{"id":"15fc64ed78ce","title":"脚本","parent":"a00498785e78","children":[{"id":"c73d6818584a","title":"脚本是可以由浏览器或者 node 环境引入执行的<br>","children":[{"id":"7c9fd7a124d7","title":"包含语句","children":[],"parent":"c73d6818584a"}],"parent":"15fc64ed78ce"}]},{"id":"f3fc703a5175","title":"模块","parent":"a00498785e78","children":[{"id":"3f9eff075e2d","title":"模块只能由 JavaScript 代码用 import 引入执行。","parent":"f3fc703a5175","children":[{"id":"35c34ca681a0","title":"包含语句，import声明，export声明","link":{"title":"05-ES6模块化教程.md","value":"https://github.com/Daotin/web/blob/master/13-模块化规范/05-ES6模块化教程.md","type":"url"},"children":[{"id":"f2b7544db1ed","title":"import声明","parent":"35c34ca681a0","children":[],"note":"import 声明有两种用法，一个是直接 import 一个模块（直接 import 一个模块，只是保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的。），另一个是带 from 的 import，它能引入模块里的一些信息。\n\n```\nimport &quot;mod&quot;; //引入一个模块\nimport v from &quot;mod&quot;;  //把模块默认的导出值放入变量v\nimport x from &quot;./a.js&quot; //引入模块中导出的默认值。\nimport {a as x, modify} from &quot;./a.js&quot;; //引入模块中的变量。\nimport * as x from &quot;./a.js&quot; //把模块中所有的变量以类似对象属性的方式引入。\n```\n第一种方式还可以跟后两种组合使用。\n\n```import\u00A0d,\u00A0{a\u00A0as\u00A0x,\u00A0modify}\u00A0from\u00A0&quot;./a.js&quot;\nimport\u00A0d,\u00A0*\u00A0as\u00A0x\u00A0from\u00A0&quot;./a.js&quot;\n```\n语法要求不带 as 的默认值永远在最前。\n\n\n&gt; 注意，这里的变量实际上仍然可以受到原来模块的控制。\n\n我们看一个例子，假设有两个模块 a 和 b。我们在模块 a 中声明了变量和一个修改变量的函数，并且把它们导出。我们用 b 模块导入了变量和修改变量的函数。\n\n模块a\n```\nexport var a = 1;\n\nexport function modify(){\n    a = 2;\n}\n\n```\n模块b\n```\nimport {a, modify} from &quot;./a.js&quot;;\n\nconsole.log(a);\n\nmodify();\n\nconsole.log(a);\n```\n当我们调用修改变量的函数后，b 模块变量也跟着发生了改变。这说明导入与一般的赋值不同，导入后的变量只是改变了名字，它仍然与原来的变量是同一个。"},{"id":"b6677360f84f","title":"export声明","parent":"35c34ca681a0","children":[],"note":"```\nexport let a = 1;\nexport const a = function();\nexport function add() {}\n```\n\nexport default 还支持一种语法，后面跟一个表达式，例如：\n\n```\nvar a = {};\nexport default a;\n```\n\n但是，这里的行为跟导出变量是不一致的，**这里导出的是值，导出的就是普通变量 a 的值，以后 a 的变化与导出的值就无关了，修改变量 a，不会使得其他模块中引入的 default 值发生改变。**\n\n---\n\nexport 中不能有 import，但是我们可以直接使用 export from 语法。\n\n```\nexport a from &quot;a.js&quot;\n```"}],"parent":"3f9eff075e2d"}]}]}],"note":"这个区分是在 ES6 引入了模块机制开始的，在 ES5 和之前的版本中，就只有一种源文件类型（就只有脚本）。\n\n---\n\n现代浏览器可以支持用 script 标签引入模块或者脚本，如果要引入模块，必须给 script 标签添加 type=“module”。如果引入脚本，则不需要 type。\n\n```\n&lt;script type=&quot;module&quot; src=&quot;xxxxx.js&quot;&gt;&lt;/script&gt;\n```\n\nscript 标签如果不加type=“module”，默认认为我们加载的文件是脚本而非模块，如果我们在脚本中写了 export，当然会抛错。"},{"id":"de48e1d70786","title":"函数体","children":[],"parent":"0d8ef2015e89"}],"note":"JavaScript 引擎除了执行脚本和模块之外，还可以执行函数。\n\n我们可以认为，宏任务中可能会执行的代码包括“脚本 (script)”“模块（module）”和“函数体（function body）”。","collapsed":true},{"id":"dccb04cb0c53","title":"全局机制","parent":"131ae7ff1ebf","children":[{"id":"c21a2c7fcc77","title":"预处理","link":{"title":"js变量提升与函数提升的详细过程.md","value":"https://github.com/Daotin/web/blob/master/%23JS阶段经验总结/01-js变量提升与函数提升的详细过程.md","type":"url"},"parent":"dccb04cb0c53","children":[{"id":"3fd143e155f2","title":"变量提升","parent":"c21a2c7fcc77","children":[{"id":"1375d789e0da","title":"注意点","children":[],"parent":"3fd143e155f2","note":"var 的作用能够穿透一切语句结构，它只认脚本、模块和函数体三种语法结构。\n\n所以对于if里面的var，虽然if(false) 中的代码永远不会被执行，但是预处理阶段并不管这个，变量依然会提升。\n\n```\nvar a = 1;\n\nfunction foo() {\n    console.log(a);\n    if(false) {\n        var a = 2;\n    }\n}\n\nfoo(); // undefined\n```\n\n因为早年 JavaScript 没有 let 和 const，只能用 var，又因为 var 除了脚本和函数体都会穿透，人民群众发明了“立即执行的函数表达式（IIFE）”这一用法，用来产生作用域。\n\n```\n\nfor(var i = 0; i &lt; 20; i ++) {\n    void function(i){\n        var div = document.createElement(&quot;div&quot;);\n        div.innerHTML = i;\n        div.onclick = function(){\n            console.log(i);\n        }\n        document.body.appendChild(div);\n    }(i);\n}\n\n```\n这段代码非常经典，常常在实际开发中见到，也经常被用作面试题，为文档添加了 20 个 div 元素，并且绑定了点击事件，打印它们的序号。\n\n我们通过 IIFE 在循环内构造了作用域，每次循环都产生一个新的环境记录，这样，每个 div 都能访问到环境中的 i。"}]},{"id":"53e2038f6bb8","title":"函数提升","task":{},"parent":"c21a2c7fcc77","children":[{"id":"3adf023698a6","title":"注意点","children":[],"parent":"53e2038f6bb8","note":"function 声明出现在 if 等语句中的情况有点复杂，它仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会提前声明，它不再被赋值：\n\n```\nconsole.log(foo); // undefined\nif(true) {\n    function foo(){\n\n    }\n}\n```\n如果没有函数声明，则会抛出错误。"}]},{"id":"565d1a950e36","title":"class 声明","parent":"c21a2c7fcc77","children":[],"note":"class 声明在全局的行为跟 function 和 var 都不一样。\n\n在 class 声明之前使用 class 名，会抛错：\n\n```\nconsole.log(c); // 报错\nclass c{\n\n}\n```\n这段代码我们试图在 class 前打印变量 c，我们得到了个错误，这个行为很像是 class 没有预处理，但是实际上并非如此。\n我们看个复杂一点的例子：\n\n```\nvar c = 1;\nfunction foo(){\n    console.log(c); // 报错\n    class c {}\n}\nfoo();\n```\n这个例子中，我们把 class 放进了一个函数体中，在外层作用域中有变量 c后试图在 class 之前打印 c。\n\n执行后，我们看到，仍然抛出了错误，如果去掉 class 声明，则会正常打印出 1，也就是说，出现在后面的 class 声明影响了前面语句的结果。\n\n这说明，**class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。**"}]},{"id":"c4e3bdc02cdb","title":"指令序言","parent":"dccb04cb0c53","children":[{"id":"35713ca8a01c","title":"脚本和模块都支持一种特别的语法，叫做指令序言（Directive Prologs）。","children":[],"parent":"c4e3bdc02cdb"},{"id":"4cacc9aba3c7","title":"\"use strict\"是 JavaScript 标准中规定的唯一一种指令序言","children":[],"parent":"c4e3bdc02cdb","note":"```\n&quot;use strict&quot;;\nfunction f(){\n    console.log(this); // null\n};\nf.call(null);\n```\n这段代码展示了严格模式的用法，我这里定义了函数 f，f 中打印 this 值，然后用 call 的方法调用 f，传入 null 作为 this 值，我们可以看到最终结果是 null 原封不动地被当做 this 值打印了出来，这是严格模式的特征。"},{"id":"7a7112f47016","title":"JavaScript 的指令序言是只有一个字符串直接量的表达式语句，<b>它只能出现在脚本、模块和函数体的最前面</b>。","children":[],"parent":"c4e3bdc02cdb","note":"```\nlet a = 1;\n&quot;use strict&quot;;\nfunction f(){\n    console.log(this); // null\n};\nf.call(null);\n```\n这种是无效的。"}]}],"collapsed":true},{"id":"8b94a4f17f93","title":"语句","parent":"131ae7ff1ebf","children":[{"id":"c05946019d22","title":"普通语句","parent":"8b94a4f17f93","children":[{"id":"c855043a32aa","title":"语句块","parent":"c05946019d22","children":[],"note":"简单理解，语句块就是一对大括号。不过，我们需要注意的是，语句块会产生作用域"},{"id":"8026aea22840","title":"空语句","parent":"c05946019d22","children":[]},{"id":"850304e5b8e9","title":"表达式语句，从最小结构开始","parent":"c05946019d22","children":[{"id":"14a1592c96ae","title":"Primary Expression 原子项，它是表达式的最小单位，它所涉及的语法结构也是优先级最高的。它包含：","summaries":[],"children":[{"id":"bf1bbad841a9","title":"直接量","children":[],"parent":"14a1592c96ae","note":"```\n&quot;abc&quot;;\n123;\nnull;\ntrue;\nfalse;\n```\n\n除这些之外，JavaScript 还能够直接量的形式定义对象，针对函数、类、数组、正则表达式等特殊对象类型，JavaScript 提供了语法层面的支持。\n\n```\n({});\n(function(){});\n(class{ });\n[];\n/abc/g;\n```\n\n需要注意，在语法层面，function、{ 和 class 开头的表达式语句与声明语句有语法冲突，所以，我们要想使用这样的表达式，必须加上括号来回避语法冲突。"},{"id":"c7e8371b7a55","title":"this","children":[],"parent":"14a1592c96ae"},{"id":"4bd04fa0e87a","title":"变量","children":[],"parent":"14a1592c96ae"}],"parent":"850304e5b8e9","note":"任何表达式加上圆括号，都被认为是 Primary Expression，这个机制使得圆括号成为改变运算优先顺序的手段。\n\n```\n(a + b);\n```","collapsed":true},{"id":"bb9600e69e09","title":"MemberExpression 成员表达式","children":[],"parent":"850304e5b8e9","note":"Member Expression 通常是用于访问对象成员的:\n\n```\na.b;\na[&quot;b&quot;];\nnew.target;\nsuper.b;\n\nf`a${b}c`;\nnew Cls(); // 带参数列表的 new 运算，注意，不带参数列表的 new 运算优先级更低，不属于 Member Expression。\n```\n\n&gt; new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。\n在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined。"},{"id":"092c7c29e40b","title":"AssignmentExpression 赋值表达式","parent":"850304e5b8e9","children":[{"id":"7e10fc99962f","title":"LeftHandSideExpression 左值表达式","parent":"092c7c29e40b","children":[{"id":"82b79f2812de","title":"NewExpression NEW 表达式","children":[],"parent":"7e10fc99962f","note":"```\nnew new Cls(1); // 相当于new (new Cls(1));\n```"},{"id":"001da86a79ab","title":"CallExpression 函数调用表达式","children":[],"parent":"7e10fc99962f","note":"它的基本形式是 Member Expression 后加一个括号里的参数列表，或者我们可以用上 super 关键字代替 Member Expression。\n\n```\na.b(c);\nsuper();\n```\n\n这看起来很简单，但是它有一些变体。比如：\n\n```\na.b(c)(d)(e);\na.b(c)[3];\na.b(c).d;\na.b(c)`xyz`;\n```\n\n这些变体的形态，跟 Member Expression 几乎是一一对应的。实际上，我们可以理解为，Member Expression 中的某一子结构具有函数调用，那么整个表达式就成为了一个 Call Expression。"}],"note":"New Expression 和 Call Expression 统称 LeftHandSideExpression，左值表达式。\n\n左值表达式就是可以放到等号左边的表达式。\n\n```\na() = b;\n```\n这样的用法其实是符合语法的，只是，原生的 JavaScript 函数，返回的值都不能被赋值（当然不排除某些宿主会提供返回引用类型的函数，这时候，赋值就是有效的了）。因此多数时候，我们看到的赋值将会是 Call Expression 的其它形式，如：\n\n```\na().c = b;\n```"},{"id":"5ded1e354f51","title":"RightHandSideExpression 右值表达式（运算符优先级）","parent":"092c7c29e40b","children":[{"id":"0904b3060ff2","title":"更新表达式 UpdateExpression","children":[],"parent":"5ded1e354f51","note":"左值表达式搭配 ++ -- 运算符，可以形成更新表达式。\n\n```\n-- a;\n++ a;\na --\na ++\n```"},{"id":"184678c96e53","title":"一元运算表达式 UnaryExpression","children":[],"parent":"5ded1e354f51","note":"更新表达式搭配一元运算符，可以形成一元运算表达式。\n\n&gt; 一元运算符的优先级低于更新运算符。\n\n```\ndelete a.b;\nvoid a;\ntypeof a;\n- a;\n~ a;\n! a;\nawait a;\n```"},{"id":"5912a9aa9dfd","title":"乘方表达式 ExponentiationExpression","children":[{"id":"9a13123ef332","title":"** 运算符","parent":"5912a9aa9dfd","children":[],"note":"** 运算是右结合的。\n\n```\n4 ** 3 ** 2 // 等价于 4 ** (3 ** 2)\n```"}],"parent":"5ded1e354f51","note":"乘方表达式也是由更新表达式构成的。它使用**号。\n\n&gt; 乘方运算符的优先级低于更新运算符。\n\n```\n++i ** 30\n2 ** 30 //正确\n-2 ** 30 //报错\n```"},{"id":"cf1031957bef","title":"乘法表达式 MultiplicativeExpression","children":[],"parent":"5ded1e354f51","note":"乘方表达式可以构成乘法表达式。\n\n&gt;  乘法运算符优先级低于乘方运算符。\n\n```\nx * 2; // * / % 都可以\n```"},{"id":"a563b4c79c0e","title":"加法表达式 AdditiveExpression","children":[],"parent":"5ded1e354f51","note":"加法表达式是由乘法表达式用加号或者减号连接构成的。\n\n&gt; 加法运算符优先级低于于乘法运算符。\n\n```\na + b * c  // 加法符号有 + 和 -\n```"},{"id":"7883590407d0","title":"移位表达式 ShiftExpression","children":[],"parent":"5ded1e354f51","note":"移位表达式由加法表达式构成，移位是一种位运算，分成三种：\n\n&gt; 移位运算符优先级低于加法运算符。\n\n```\n&lt;&lt; 向左移位\n&gt;&gt; 向右移位\n&gt;&gt;&gt; 无符号向右移位\n```\n\n移位运算把操作数看做二进制表示的整数，然后移动特定位数。所以左移 n 位相当于乘以 2 的 n 次方，右移 n 位相当于除以 2 取整 n 次。\n\n普通移位会保持正负数。无符号移位会把减号视为符号位 1，同时参与移位：\n\n```\n-1 &gt;&gt;&gt; 1 // 2147483647\n```\n\n&gt; 在 JavaScript 中，二进制操作整数并不能提高性能，移位运算这里也仅仅作为一种数学运算存在，这些运算存在的意义也仅仅是照顾 C 系语言用户的习惯了。"},{"id":"9fbd273226e0","title":"关系表达式 RelationalExpression","parent":"5ded1e354f51","children":[],"note":"移位表达式可以构成关系表达式，这里的关系表达式就是大于、小于、大于等于、小于等于等运算符号连接，统称为关系运算。\n\n&gt; 关系运算符优先级低于移位运算符。\n\n```\n&lt;=\n&gt;=\n&lt;\n&gt;\ninstanceof \nin\n```\n\n需要注意，这里的 &lt;= 和 &gt;= 关系运算，完全是针对数字的，所以 &lt;= 并不等价于 &lt; 或 ==。例如：\n\n```\nnull &lt;= undefined\n//false\nnull == undefined\n//true\n```"},{"id":"007417b3a0fc","title":"相等表达式 EqualityExpression","children":[{"id":"5b32bfe77e6f","title":"==符号","children":[],"parent":"007417b3a0fc","note":"虽然标准中写的 == 十分复杂，但是归根结底，类型不同的变量比较时==运算只有三条规则：\n\n- undefined 与 null 相等；\n- 字符串和 bool 都转为数字再比较；\n- 对象转换成原始类型再比较。\n\n```\nfalse == &#39;0&#39; //true\ntrue == &#39;true&#39; //false\n[] == 0 //true\n[] == false //true\nnew Boolean(&#39;false&#39;) == false //false\n```\n\n这里不太符合直觉的有两点：\n- 一个是即使字符串与 boolean 比较，也都要转换成数字；\n- 另一个是对象如果转换成了原始类型跟等号另一边类型恰好相同，则不需要转换成数字。\n\n&gt; 建议：**仅在确认 == 发生在 Number 和 String 类型之间时使用。**\n\n"}],"parent":"5ded1e354f51","note":"相等表达式是由关系表达式用相等比较运算符（如 ==）连接构成的。\n\n&gt; 相等运算符优先级低于关系运算符。\n\n```\na instanceof &quot;object&quot; == true\n```\n\n相等表达式由四种运算符和关系表达式构成，我们来看一下运算符：\n\n```\n==\n!=\n===\n!==\n```\n"},{"id":"c9e7869ed86f","title":"位运算表达式","parent":"5ded1e354f51","children":[],"note":"```\na | b 按位或\na & b 按位与\na ^ b 按位异或\n```"},{"id":"cca90733741b","title":"逻辑与表达式和逻辑或表达式","parent":"5ded1e354f51","children":[],"note":"```\n逻辑与 &&\n逻辑或 ||\n```\n\n&gt; 注意：逻辑表达式具有**短路**的特性。"},{"id":"5592f39935f1","title":"条件表达式 （三目运算符）<br>","children":[],"parent":"5ded1e354f51"}],"note":"等号右边的部分。\n\n"}],"note":"```\na = b\na = b = c = d // 等价于 a = (b = (c = d))\na += b;\na /= b;\n```"},{"id":"0b5207e97ca0","title":"Expression 表达式","children":[],"parent":"850304e5b8e9","note":"在 JavaScript 中，比赋值运算优先级更低的就是逗号运算符了。我们可以把逗号可以理解为一种小型的分号。\n\n```\na = b, b = 1, null;\n```\n\n逗号分隔的表达式会顺次执行，就像不同的表达式语句一样。**“整个表达式的结果”就是“最后一个逗号后的表达式结果”**。\n\n\n比如我们文中的例子，整个“a = b, b = 1, null;”表达式的结果就是“，”后面的null。\n\n&gt; 注意：export 后只能跟赋值表达式，意思就是表达式中不能含有逗号。"}],"note":"比如：函数调用，变量赋值，自增、自减等等。"},{"id":"41246420af40","title":"if语句","parent":"c05946019d22","children":[]},{"id":"3ac5c0f6adff","title":"switch语句","parent":"c05946019d22","children":[{"id":"6042b59c0479","title":"<b><font color=\"#0076b3\">在 C 时代，switch 生成的汇编代码性能是略优于 if else 的，但是对 JavaScript 来说，则无本质区别。我个人的看法是，现在 switch 已经完全没有必要使用了，应该用 if else 结构代替。</font></b>","children":[],"parent":"3ac5c0f6adff"}],"collapsed":true},{"id":"c5ad10137c4f","title":"循环语句","parent":"c05946019d22","children":[{"id":"64c2df37af47","title":"for","parent":"c5ad10137c4f","children":[]},{"id":"009401db829e","title":"for in","parent":"c5ad10137c4f","children":[],"note":"for in 循环: 枚举对象的属性。\n\n```\nlet o = { a: 10, b: 20}\nObject.defineProperty(o, &quot;c&quot;, {enumerable:false, value:30})\n\nfor(let p in o)\n    console.log(p);\n\n```\n\n这段代码中，我们定义了一个对象 o，给它添加了不可枚举的属性 c，之后我们用 for in 循环枚举它的属性，我们会发现，输出时得到的只有 a 和 b。\n\n如果我们定义 c 这个属性时，enumerable 为 true，则 for in 循环中也能枚举到它。"},{"id":"b5022f569e4f","title":"for of","parent":"c5ad10137c4f","children":[],"note":"与 for in 的区别：\n\n[for in 与 for of 区别](https://segmentfault.com/q/1010000006658882)"},{"id":"aea44c73f0bb","title":"for await of","parent":"c5ad10137c4f","children":[]},{"id":"26892311770e","title":"while","parent":"c5ad10137c4f","children":[]}],"collapsed":true},{"id":"b4db7d2f1df3","title":"return语句","parent":"c05946019d22","children":[]},{"id":"a36aed283e86","title":"break语句","parent":"c05946019d22","children":[]},{"id":"288e228d0e72","title":"continue语句","parent":"c05946019d22","children":[],"note":"break 语句用于跳出循环语句或者 switch 语句，continue 语句用于结束本次循环并继续循环。\n\n\n需要注意的是，它们都有带标签的用法。\n\n```\nouter:for(let i = 0; i &lt; 100; i++)\n    inner:for(let j = 0; j &lt; 100; j++)\n        if( i == 50 && j == 50)\n            break outer;\nouter:for(let i = 0; i &lt; 100; i++)\n    inner:for(let j = 0; j &lt; 100; j++)\n        if( i &gt;= 50 && j == 50)\n            continue outer;\n```\n带标签的 break 和 continue 可以控制自己被外层的哪个语句结构消费，这可以跳出复杂的语句结构。"},{"id":"e4cd2433d00c","title":"<strike>with语句</strike>","parent":"c05946019d22","children":[]},{"id":"6807b73775ae","title":"throw语句","parent":"c05946019d22","children":[]},{"id":"29b99f98fcdc","title":"try catch语句","parent":"c05946019d22","children":[],"note":"try 语句用于捕获异常，用 throw 抛出的异常，可以在 try 语句的结构中被处理掉：try 部分用于标识捕获异常的代码段，catch 部分则用于捕获异常后做一些处理，而 finally 则是用于执行后做一些必须执行的清理工作。"},{"id":"acf18222c78a","title":"debugger语句","parent":"c05946019d22","children":[],"note":"ebugger 语句的作用是：通知调试器在此断点。**在没有调试器挂载时，它不产生任何效果。**"}]},{"id":"810b35eadc1d","title":"声明式语句","parent":"8b94a4f17f93","children":[{"id":"4175f18177cc","title":"变量声明","summaries":[{"id":"7c548713e866","summary":true,"title":"概要","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"range":0,"children":[],"parent":"4175f18177cc","part":"right","note":"var 会穿透if for语句\n```var a = 1;\nif(true){\n    var a = 2;\n    console.log(a); // 2\n}\nconsole.log(a); // 2\n```\n\n---\n\nlet，const 变量不能重复声明，否则会报错\n\n```\nlet a = 1;\nconst a = 2; // 报错\n```\n\nlet 和 const 声明虽然看上去是执行到了才会生效，但是实际上，它们还是会被预处理。如果当前作用域内有声明，就无法访问到外部的变量。\n\n```\nconst a = 2;\nif(true){\n    console.log(a); //报错\n    const a = 1;   \n}\n```\n\n--- \n\nclass 声明类似let/const，都是作用于块级作用域，预处理阶段则会屏蔽外部变量。\n\n```\nconst a = 2;\nif(true){\n    console.log(a); //报错\n    class a {}\n}\n```"}],"children":[{"id":"d9162dc0ee64","title":"var","children":[],"parent":"4175f18177cc","summaries":[],"note":"#### 通常let和const是更好的选择，那么如何正确使用var？\n\n遵循三个原则：\n\n- 声明同时必定初始化；\n- 尽可能在离使用的位置近处声明；\n- 不要在意重复声明。\n\n\n```\nvar x = 1, y = 2;\ndoSth(x, y);\n\nfor(var x = 0; x &lt; 10; x++)\n    doSth2(x);\n```"},{"id":"3f164625245a","title":"let","parent":"4175f18177cc","children":[]},{"id":"d088ba4de42c","title":"const","parent":"4175f18177cc","children":[]},{"id":"d596625f7508","title":"class声明","parent":"4175f18177cc","children":[]}],"parent":"810b35eadc1d"},{"id":"788cc53b9489","title":"函数声明","parent":"810b35eadc1d","children":[{"id":"7985fa53a866","title":"普通函数声明","parent":"788cc53b9489","children":[]},{"id":"dabd1a9a7aa7","title":"async函数声明","parent":"788cc53b9489","children":[]},{"id":"0b47790ff638","title":"generator函数声明","parent":"788cc53b9489","children":[]},{"id":"5a8180e2763d","title":"async generator 函数声明","parent":"788cc53b9489","children":[]}],"summaries":[{"summary":true,"id":"b14372b4a7c8","title":"概要","range":1,"style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"parent":"788cc53b9489","children":[],"part":"right","note":"```\n\nfunction foo(){\n\n}\n\nfunction* foo(){\n    yield 1;\n    yield 2;\n    yield 3;\n}\n\nasync function foo(){\n    await sleep(3000);\n    \n}\n\nasync function* foo(){\n    await sleep(3000);\n    yield 1;\n}\n```"}]}],"collapsed":false}],"collapsed":true}]}],"collapsed":false},{"id":"5e84ac2110af","title":"语义<br>","parent":"root","children":[]},{"id":"0c43d3087024","title":"运行时","children":[{"id":"eda3563a1b3d","title":"数据结构","parent":"0c43d3087024","children":[{"id":"29f176654c61","title":"类型","parent":"eda3563a1b3d","children":[{"id":"b6dc2806f3f6","title":"对象","parent":"29f176654c61","children":[]}]},{"id":"465f9aa4b203","title":"实例","parent":"eda3563a1b3d","children":[{"id":"cfd206416421","title":"应用与机制","parent":"465f9aa4b203","children":[]}]}]},{"id":"d0e26e03d5e3","title":"算法（执行过程）","parent":"0c43d3087024","children":[{"id":"8b755b481f8e","title":"事件循环和微任务执行","parent":"d0e26e03d5e3","children":[{"id":"cc53908fffe9","title":"宏观任务","parent":"8b755b481f8e","children":[{"id":"2f608bb235a3","title":"JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把宏观任务的队列称为<b>事件循环</b>。","children":[],"parent":"cc53908fffe9"},{"id":"7d9ea979bde6","title":"在宏观任务中，JavaScript 的 Promise 还会产生异步代码，<font color=\"#f15a23\">JavaScript 必须保证这些异步代码在一个宏观任务中完成</font>，因此，每个宏观任务中又包含了一个微观任务队列：","parent":"cc53908fffe9","children":[],"image":{"w":71,"url":"http://cdn.processon.com/5e4f8fc8e4b0c037b5f813e7?e=1582276056&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:oBvNxrZWWzBSblsnELh6N1PQamA=","h":82}},{"id":"5dcace69903f","title":"有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。<br>setTimeout 等宿主 API，则会添加宏观任务。<br>","parent":"cc53908fffe9","children":[]}],"note":"宿主，比如浏览器发起的任务"},{"id":"5757bd9f49d1","title":"微观任务","children":[{"id":"62aaeaec3ccc","title":"Promise","children":[{"id":"db8f4a814975","title":"基本用法","parent":"62aaeaec3ccc","children":[{"id":"7ec776d291d6","title":"Promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：<br><br>resolve ：异步操作执行成功后的回调函数（将状态改为成功）<br>reject：异步操作执行失败后的回调函数（将状态改为失败）","parent":"db8f4a814975","children":[],"note":"```\nlet p = new Promise((resolve, reject) =&gt; {\n    //做一些异步操作\n    setTimeout(() =&gt; {\n        console.log(&#39;执行完成&#39;);\n        resolve(&#39;我是成功！！&#39;);\n    }, 2000);\n});\n\np.then(\n// 状态为成功时的回调\n(data) =&gt; {\n    console.log(data);\n}, \n// 状态为失败时的回调\n(data) =&gt; {\n    console.log(data);\n});\n```"}]},{"id":"58d06a23008b","title":"执行顺序","children":[{"id":"dfff21150e53","title":"正常流代码先于异步执行：示例1","children":[{"id":"dcdd78c632e8","title":"我们执行这段代码（代码在备注）后，注意输出的顺序是 a b c。在进入 console.log(“b”) 之前，毫无疑问 r 已经得到了 resolve，<b><font color=\"#0076b3\">但是 Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。</font></b><br>","parent":"dfff21150e53","children":[],"note":""}],"parent":"58d06a23008b","note":"一个宏观任务可以有多条代码，都算一个宏观任务。\n\n```\n\n    var r = new Promise(function(resolve, reject){\n        console.log(&quot;a&quot;);\n        resolve()\n    });\n    r.then(() =&gt; console.log(&quot;c&quot;));\n    console.log(&quot;b&quot;)\n```"},{"id":"49012c8f687f","title":"微任务始终优先于宏任务","parent":"58d06a23008b","children":[{"id":"e1bebfa09bdf","title":"示例2","children":[{"id":"3c083c4a8917","title":"我们发现，不论代码顺序如何，<b><font color=\"#0076b3\">d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。</font></b>","parent":"e1bebfa09bdf","children":[]}],"parent":"49012c8f687f","note":"```\n    var r = new Promise(function(resolve, reject){\n        console.log(&quot;a&quot;);\n        resolve()\n    });\n    setTimeout(()=&gt;console.log(&quot;d&quot;), 0)\n    r.then(() =&gt; console.log(&quot;c&quot;));\n    console.log(&quot;b&quot;)\n```"},{"id":"fbe2e74694e8","title":"示例3","parent":"49012c8f687f","children":[],"note":"```\n\n    setTimeout(()=&gt;console.log(&quot;d&quot;), 0)\n\n    var r = new Promise(function(resolve, reject){\n        resolve()\n    });\n    r.then(() =&gt; { \n        var begin = Date.now();\n        // 确保1s后执行\n        while(Date.now() - begin &lt; 1000);\n        console.log(&quot;c1&quot;) \n        new Promise(function(resolve, reject){\n            resolve()\n        }).then(() =&gt; console.log(&quot;c2&quot;))\n    });\n```\n\n打印顺序： c1,c2 ,d"}]},{"id":"46dc893aa79d","title":"<b>如何分析异步执行的顺序？</b>","parent":"58d06a23008b","children":[{"id":"f5d8f9457c4d","title":"1、首先我们分析有多少个宏任务；<br>","parent":"46dc893aa79d","children":[]},{"id":"6f9fad09a029","title":"2、在每个宏任务中，分析有多少个微任务；","children":[],"parent":"46dc893aa79d"},{"id":"ea12a46adf5e","title":"3、根据调用次序，确定宏任务中的微任务执行次序；","children":[],"parent":"46dc893aa79d"},{"id":"06d21dc17301","title":"4、根据宏任务的触发规则和调用次序，确定宏任务的执行次序；<br>","children":[],"parent":"46dc893aa79d"}]}],"parent":"62aaeaec3ccc"},{"id":"e8a98c4053b0","title":"ES7新特性：async/await","parent":"62aaeaec3ccc","children":[]},{"id":"d424375378b3","title":"小练习：我们现在要实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色，你会怎样编写这个代码呢？","parent":"62aaeaec3ccc","children":[],"note":"```\nlet div = document.querySelector(&#39;div&#39;);\n\nfunction red() {\n    return new Promise(function(resolve, reject) {\n        div.style.backgroundColor = &#39;red&#39;;\n        setTimeout(green, 2000);\n    })\n}\n\nfunction green() {\n    return new Promise(function(resolve, reject) {\n        div.style.backgroundColor = &#39;green&#39;;\n        setTimeout(yellow, 3000);\n    })\n}\n\nfunction yellow() {\n    return new Promise(function(resolve, reject) {\n        div.style.backgroundColor = &#39;yellow&#39;;\n        setTimeout(red, 1000);\n    })\n}\n\ngreen();\n```"}],"parent":"5757bd9f49d1","note":"从本意上讲，它不返回结果，而是返回承诺（状态），根据这个状态，它承诺会给你不同的结果。"}],"parent":"8b755b481f8e","note":"JavaScript引擎自己发起的任务，比如Promise 异步请求。"}],"collapsed":true},{"id":"bfaa4806ad18","title":"函数的执行","parent":"d0e26e03d5e3","children":[{"id":"5ee8e8b39238","title":"执行上下文","children":[],"parent":"bfaa4806ad18"},{"id":"9107ca322119","title":"作用域","children":[],"parent":"bfaa4806ad18"},{"id":"58b9e937e172","title":"闭包","parent":"bfaa4806ad18","children":[]},{"id":"979731f58076","title":"this","children":[],"parent":"bfaa4806ad18"}]},{"id":"f4ac275aa55b","title":"语句级的执行原理","parent":"d0e26e03d5e3","children":[{"id":"25888bde2ab9","title":"先来个小实验","parent":"f4ac275aa55b","children":[],"note":"```\n\nfunction foo(){\n  try{\n    return 0;\n  } catch(err) {\n\n  } finally {\n    console.log(&quot;a&quot;)\n  }\n}\n\nconsole.log(foo());\n```\n\n通过实际试验，我们可以看到，finally 确实执行了，而且 return 语句也生效了，foo() 返回了结果 0。\n\n虽然 return 执行了，但是函数并没有立即返回，又执行了 finally 里面的内容，这样的行为违背了很多人的直觉。"},{"id":"70c11f24592c","title":"Completion Record类型","children":[{"id":"84ea5770490a","title":"[[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；","children":[],"parent":"70c11f24592c"},{"id":"6481eaa78de4","title":"[[value]] 表示语句的返回值，如果语句没有，则是 empty；<br>","children":[],"parent":"70c11f24592c"},{"id":"277089053c0f","title":"[[target]] 表示语句的目标，通常是一个 JavaScript 标签（标签在后文会有介绍）。","children":[],"parent":"70c11f24592c"}],"parent":"f4ac275aa55b","note":"Completion Record 表示一个语句执行完之后的结果。它有三个字段：","collapsed":false},{"id":"1848678fd2c7","title":"语句分类","children":[{"id":"3941ea6e312c","title":"普通语句","children":[{"id":"7e370814a8dc","title":"声明类语句","parent":"3941ea6e312c","children":[{"id":"09e14b6f38e0","title":"var","children":[],"parent":"7e370814a8dc"},{"id":"778574729284","title":"let","children":[],"parent":"7e370814a8dc"},{"id":"7d15ea601a7c","title":"const","children":[],"parent":"7e370814a8dc"},{"id":"b911a0de48e4","title":"函数声明","children":[],"parent":"7e370814a8dc"},{"id":"c656cd4b948e","title":"类声明","children":[],"parent":"7e370814a8dc"}]},{"id":"1f1955b52988","title":"表达式语句","parent":"3941ea6e312c","children":[],"note":"只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处。\n\n```\n// 在chrome中输入表达式，有undefined返回\n&gt; var i = 1;\n&lt; undefined\n```\n\nPS：其实按照之前的讲解应该返回empty，为什么返回时undefined？这是Chrome规定的。"},{"id":"a232742625c9","title":"空语句","parent":"3941ea6e312c","children":[]},{"id":"3d2c79094045","title":"with语句","parent":"3941ea6e312c","children":[]},{"id":"6e62620d7026","title":"debugger语句","parent":"3941ea6e312c","children":[]}],"parent":"1848678fd2c7","summaries":[{"summary":true,"id":"e9e72d10a8a5","title":"type：normal","range":0,"parent":"3941ea6e312c","children":[],"part":"right","note":"JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。"}],"note":"我们把不带控制能力的语句称为普通语句","collapsed":true},{"id":"52e407c424e1","title":"语句块","parent":"1848678fd2c7","children":[],"summaries":[{"summary":true,"id":"4c5540e2add9","title":"type: normal/return","range":1,"parent":"52e407c424e1","children":[],"part":"right","note":"如果语句块内部的语句的 Completion Record 的[[type]] 如果不为 normal，会打断语句块后续的语句执行。\n\n---\n\n普通的语句块：\n\n```\n\n{\n  var i = 1; // normal, empty, empty\n  i ++; // normal, 1, empty\n  console.log(i) //normal, undefined, empty\n} // normal, undefined, empty\n```\n我们看到，在一个 block 中，如果每一个语句都是 normal 类型，那么它会顺次执行。\n\n---\n\n加入return 的语句块\n\n```\n\n{\n  var i = 1; // normal, empty, empty\n  return i; // return, 1, empty\n  i ++; \n  console.log(i)\n} // return, 1, empty\n```\n但是假如我们在 block 中插入了一条 return 语句，产生了一个非 normal 记录，那么整个 block 会成为非 normal。这个结构就保证了非 normal 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。"}],"note":"语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。"},{"id":"4a66e8f6003d","title":"控制型语句","summaries":[{"id":"93eda79444df","summary":true,"title":"表格中的“穿透”和“消费”是什么意思？","range":2,"children":[],"parent":"4a66e8f6003d","image":{"w":327,"h":177,"url":"http://cdn.processon.com/5e50ed45e4b0362764fc6e52?e=1582365525&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:M4vckhS3E68OH5hTkMI45GYVkE4="},"part":"right","note":"“消费”指对应的代码被有效的执行了。\n\n“穿透”就是指不在当前这一层处理，向外逐层寻找可以“消费”的那一层，直到最后都没找到就报错。\n\n“特殊处理”，可以理解为“特殊消费”，比如 finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。"}],"parent":"1848678fd2c7","children":[{"id":"3aef62e51215","title":"对内部影响","parent":"4a66e8f6003d","children":[{"id":"fc8a8883bace","title":"if<br>","summaries":[],"children":[],"parent":"3aef62e51215"},{"id":"b0da494764c2","title":"switch","parent":"3aef62e51215","children":[],"summaries":[]},{"id":"145551497e11","title":"for","summaries":[],"children":[],"parent":"3aef62e51215"},{"id":"8b4c5904fde9","title":"while","parent":"3aef62e51215","children":[],"summaries":[]},{"id":"2116c65347cf","title":"try","summaries":[],"children":[],"parent":"3aef62e51215"}]},{"id":"29667a105ac2","title":"对外部影响","parent":"4a66e8f6003d","children":[{"id":"ac33017e2b77","title":"break","parent":"29667a105ac2","children":[],"summaries":[]},{"id":"121588cb7845","title":"continue","summaries":[],"children":[],"parent":"29667a105ac2"},{"id":"8640aefe7188","title":"return","parent":"29667a105ac2","children":[],"summaries":[]},{"id":"c3f3b857b835","title":"throw","summaries":[],"children":[],"parent":"29667a105ac2"}]}],"collapsed":false},{"id":"7f7617146bcd","title":"带标签的语句","parent":"1848678fd2c7","children":[{"id":"6e40fd7530c8","title":"任何 JavaScript 语句是可以加标签的，在语句前加冒号即可：","children":[],"parent":"7f7617146bcd","note":"例如：\n\n```\nfirstStatement: var i = 1;\n```\n\n大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：**与完成记录类型中的 target 相配合，用于跳出多层循环。**\n\n```\n    outer: while(true) {\n      inner: while(true) {\n          break outer; // 直接跳出外部while\n      }\n    }\n    console.log(&quot;finished&quot;)\n```\n\nbreak/continue 语句如果后跟了关键字，会产生带 target 的完成记录。一旦完成记录带了 target，那么只有拥有对应 label 的循环语句会消费它。\n\n"}]}],"parent":"f4ac275aa55b","collapsed":false}],"collapsed":true}],"collapsed":false}],"parent":"root","collapsed":false}],"note":"用一定的词法和语法，表达一定语义，从而操作运行时。"}},"meta":{"id":"5e61a2e9e4b09d2387944b78","member":"5e488f9ee4b03d4e28b975b2","exportTime":"2020-03-19 10:56:33","diagramInfo":{"category":"mind_free","title":"4 JavaScript","created":"2020-03-06 09:10:01","creator":"5e488f9ee4b03d4e28b975b2","modified":"2020-03-06 09:10:01"},"type":"ProcessOn Schema File","version":"1.0"}}