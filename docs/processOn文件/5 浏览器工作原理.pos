{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","structure":"mind_right","leftChildren":[],"title":"浏览器的工作原理（大致流程）","root":true,"theme":"caihongthinner","children":[{"id":"40d9d0a44222","title":"工作原理","children":[{"id":"94ccbfcd6a8e","title":"解析","parent":"40d9d0a44222","children":[]},{"id":"803dd616c794","title":"构建DOM树","parent":"40d9d0a44222","children":[]},{"id":"1f5049cf5d5a","title":"渲染，合成，绘制","parent":"40d9d0a44222","children":[]}],"parent":"root"},{"id":"0e63b3038344","title":"API","parent":"root","children":[{"id":"54c767250254","title":"DOM","children":[{"id":"27d0a6cd609f","title":"节点：DOM 树形结构中的节点相关 API。","children":[{"id":"cf0d43460fb9","title":"Node（DOM树根节点）","children":[{"id":"6e709c654b7b","title":"Element 元素节点，跟标签相对应","parent":"cf0d43460fb9","children":[{"id":"f2abf845c2f5","title":"attribute 属性","children":[{"id":"5fd674f26775","title":"getAttribute<br>","parent":"f2abf845c2f5","children":[]},{"id":"3b60206dd469","title":"setAttribute<br>","parent":"f2abf845c2f5","children":[]},{"id":"94b548812643","title":"removeAttribute<br>","parent":"f2abf845c2f5","children":[]},{"id":"0721f5987129","title":"hasAttribute","parent":"f2abf845c2f5","children":[]},{"id":"b6c919951535","title":"getAttributeNode","parent":"f2abf845c2f5","children":[]},{"id":"21f322157972","title":"setAttributeNode","parent":"f2abf845c2f5","children":[]},{"id":"3881c82c97b6","title":"attributes 对象","parent":"f2abf845c2f5","children":[]}],"parent":"6e709c654b7b"},{"id":"f7813a6965d6","title":"查找元素","children":[{"id":"fca87289c25f","title":"document节点","parent":"f7813a6965d6","children":[{"id":"9e0fe746d5ff","title":"getElementById","children":[],"parent":"fca87289c25f"},{"id":"127027608bda","title":"getElementsByName","children":[],"parent":"fca87289c25f"},{"id":"62426cfd9738","title":"getElementsByTagName<br>","children":[],"parent":"fca87289c25f"},{"id":"0858ff09caa8","title":"getElementsByClassName<br>","children":[],"parent":"fca87289c25f"},{"id":"da5ba8894e48","title":"querySelector（性能最低）<br>","children":[],"parent":"fca87289c25f"},{"id":"bb0c3bd7828f","title":"querySelectorAll","children":[],"parent":"fca87289c25f"}],"note":"getElementsByName、getElementsByTagName、getElementsByClassName 获取的集合并非数组，而是一个`能够动态更新`的集合。\n\n也就是说后面新增加的元素，也会出现在之前获取的集合中。"}],"parent":"6e709c654b7b"},{"id":"c58872a44cd3","title":"遍历","parent":"6e709c654b7b","children":[{"id":"a4795620b98b","title":"<strike>NodeIterator </strike>","parent":"c58872a44cd3","children":[]},{"id":"1c557531d792","title":"<strike>TreeWalker </strike>","parent":"c58872a44cd3","children":[]}],"note":"通过 Node 的相关属性，我们可以用 JavaScript 遍历整个树。实际上，DOM API 中还提供了 NodeIterator 和 TreeWalker 来遍历树。\n\n但是，建议需要遍历 DOM 的时候，直接`使用递归和 Node 的属性`。"}]},{"id":"bb43d69c2486","title":"Document 文档根节点","children":[],"parent":"cf0d43460fb9"},{"id":"96e30a742fd0","title":"CharacterData 字符数据","parent":"cf0d43460fb9","children":[{"id":"e8b07175894e","title":"Text 文本节点","children":[{"id":"9df97d666b56","title":"CDATASection：CDATA节点","children":[],"parent":"e8b07175894e"}],"parent":"96e30a742fd0"},{"id":"cee300ee5784","title":"Comment 注释<br>","children":[],"parent":"96e30a742fd0"},{"id":"8a71265382da","title":"ProcessingInstruction 处理信息<br>","children":[],"parent":"96e30a742fd0"}]},{"id":"75e542228057","title":"Documentfragment 文档片段","children":[],"parent":"cf0d43460fb9"},{"id":"f8cf26125ea3","title":"DocumentType 文档类型","parent":"cf0d43460fb9","children":[]}],"parent":"27d0a6cd609f","note":"### Node属性：\n\n```\nparentNode\nchildNodes\nfirstChild\nlastChild\nnextSibling\npreviousSibling\n```\n\n### 操作 DOM 树的 API\n\n```\nappendChild\ninsertBefore\nremoveChild\nreplaceChild\n```\n\n### Node 高级API\n\n```\ncompareDocumentPosition 是一个用于比较两个节点中关系的函数。\ncontains 检查一个节点是否包含另一个节点的函数。\nisEqualNode 检查两个节点是否完全相同。\nisSameNode 检查两个节点是否是同一个节点，实际上在 JavaScript 中可以用“===”。\ncloneNode 复制一个节点，如果传入参数 true，则会连同子元素做深拷贝。\n```\n\n### Node 创建\n\n```\ncreateElement\ncreateTextNode\ncreateCDATASection\ncreateComment\ncreateProcessingInstruction\ncreateDocumentFragment\ncreateDocumentType\n```"}],"parent":"54c767250254","collapsed":true},{"id":"797d85e77205","title":"遍历：遍历 DOM 需要的 API。","parent":"54c767250254","children":[]},{"id":"58d4f708d91b","title":"Range：操作文字范围相关 API。","parent":"54c767250254","children":[{"id":"5e7f60b5c078","title":"创建 Range 一般是通过设置它的起止来实现","parent":"58d4f708d91b","children":[],"note":"```\nvar range = new Range(),\n    firstText = p.childNodes[1],\n    secondText = em.firstChild\nrange.setStart(firstText, 9) // do not forget the leading space\nrange.setEnd(secondText, 4)\n```"},{"id":"bba93a312ddc","title":"从用户选中区域创建","children":[],"parent":"58d4f708d91b","note":"```\nvar range = document.getSelection().getRangeAt(0);\n```"},{"id":"c8d678d5c4ef","title":"更改 Range 选中区段内容<br>","children":[{"id":"25448e9cac4e","title":"取出&nbsp;extractContents<br>","parent":"c8d678d5c4ef","children":[]},{"id":"ea70016acfca","title":"插入&nbsp;insertNode ","parent":"c8d678d5c4ef","children":[]}],"parent":"58d4f708d91b","note":"```\n\nvar range = new Range(),\n    firstText = p.childNodes[1],\n    secondText = em.firstChild\nrange.setStart(firstText, 9) // do not forget the leading space\nrange.setEnd(secondText, 4)\n\n// 取出 插入\nvar fragment = range.extractContents()\nrange.insertNode(document.createTextNode(&quot;aaaa&quot;))\n```"}],"note":"Range API 表示一个 HTML 上的范围，这个范围是`以文字为最小单位`的，所以 Range 不一定包含完整的节点，它可能是 Text 节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素。\n\n-\n\n一般用在富文本编辑类的任务。"},{"id":"d2b63a7fd6eb","title":"事件：触发和监听事件相关 API。","children":[{"id":"75e25bb5b7be","title":"捕获与冒泡","children":[],"parent":"d2b63a7fd6eb","note":"&gt; **在一个事件发生时，捕获过程跟冒泡过程总是先后发生，跟你是否监听毫无关联。**"},{"id":"4049e1a0493f","title":"addEventListener 三个参数","parent":"d2b63a7fd6eb","children":[{"id":"1653abdfadfb","title":"事件名称","children":[],"parent":"4049e1a0493f","note":""},{"id":"14b24afdf9e6","title":"事件处理函数","parent":"4049e1a0493f","children":[],"note":"事件处理函数不一定是函数，也可以是个 JavaScript 具有 `handleEvent` 方法的对象，看下例子：\n\n```\nvar o = {\n  handleEvent: event =&gt; console.log(event)\n}\ndocument.body.addEventListener(&quot;keydown&quot;, o, false);\n```"},{"id":"ac0ceb42787a","title":"捕获(true)还是冒泡(false)","parent":"4049e1a0493f","children":[],"note":"第三个参数不一定是 bool 值，也可以是个对象，它提供了更多选项。\n\n- `once`：只执行一次。\n- `passive`：承诺此事件监听不会调用 \n- `preventDefault`，这有助于性能。\n- `useCapture`：是否捕获（否则冒泡）。"}],"note":""},{"id":"04d5cd5f4d41","title":"焦点","children":[{"id":"6d47569552dd","title":"获取焦点 document.body.focus();<br>","children":[],"parent":"04d5cd5f4d41"},{"id":"64ffd2dfddcb","title":"失去焦点&nbsp;document.body.blur();","parent":"04d5cd5f4d41","children":[]}],"parent":"d2b63a7fd6eb"},{"id":"8793eefdd2f9","title":"自定义事件","parent":"d2b63a7fd6eb","children":[{"id":"3826a0e511f1","title":"创建自定义事件：<font color=\"#0076b3\">var evt = new Event(\"look\", {\"bubbles\":true, \"cancelable\":false});</font>","parent":"8793eefdd2f9","children":[]},{"id":"695574bbe019","title":"触发自定义事件：<font color=\"#0076b3\">document.dispatchEvent(evt);</font>","parent":"8793eefdd2f9","children":[]},{"id":"738b44efa407","title":"<strike>旧的自定义事件方法（使用 document.createEvent 和 initEvent）已经被废弃。</strike>","children":[],"parent":"8793eefdd2f9"}]}],"parent":"54c767250254"}],"parent":"0e63b3038344"},{"id":"c3e686b715a3","title":"CSSOM","children":[{"id":"cd441131f5c5","title":"CSSOM 描述样式表规则","children":[{"id":"50524fddbd1b","title":"API","children":[{"id":"b7c42a8a6fc8","title":"获取文档中所有的样式表：&nbsp;document.styleSheets<br>","children":[],"parent":"50524fddbd1b"},{"id":"89a9f4800a31","title":"修改样式表中的内容","children":[],"parent":"50524fddbd1b","note":"```\ndocument.styleSheets[0].insertRule(&quot;p { color:pink; }&quot;, 0)\ndocument.styleSheets[0].removeRule(0)\n```"},{"id":"241f592fd296","title":"获取样式表中特定的规则（Rule）","parent":"50524fddbd1b","children":[],"note":"```\ndocument.styleSheets[0].cssRules\n```"}],"parent":"cd441131f5c5"}],"parent":"c3e686b715a3"},{"id":"6377eac22de3","title":"CSSOM View 元素视图相关","children":[{"id":"cdecbd7f1a3f","title":"窗口 API：用于操作浏览器窗口的位置、尺寸等。","children":[{"id":"c127d869b5b0","title":"moveTo(x, y) 窗口移动到屏幕的特定坐标；","children":[],"parent":"cdecbd7f1a3f"},{"id":"2caf540dab32","title":"moveBy(x, y) 窗口移动特定距离；<br>","children":[],"parent":"cdecbd7f1a3f"},{"id":"00d7d29ca52c","title":"resizeTo(x, y) 改变窗口大小到特定尺寸；<br>","children":[],"parent":"cdecbd7f1a3f"},{"id":"48114aa7f14e","title":"resizeBy(x, y) 改变窗口大小特定尺寸。","children":[],"parent":"cdecbd7f1a3f"},{"id":"03671994dab1","title":" window.open() 的第三个参数","children":[],"parent":"cdecbd7f1a3f","note":"```\nwindow.open(&quot;about:blank&quot;, &quot;_blank&quot; ,&quot;width=100,height=100,left=100,right=100&quot; )\n```"}],"parent":"6377eac22de3"},{"id":"610269d5ca3f","title":"滚动 API","children":[{"id":"6d1881c50527","title":"视口滚动 API","parent":"610269d5ca3f","children":[{"id":"d666855729fb","title":"scrollX 是视口的属性，表示 X 方向上的当前滚动距离，有别名 pageXOffset；<br>","parent":"6d1881c50527","children":[]},{"id":"b206ae550b53","title":"scrollY 是视口的属性，表示 Y 方向上的当前滚动距离，有别名 pageYOffset；<br>","parent":"6d1881c50527","children":[]},{"id":"defc4b468984","title":"scroll(x, y) 使得页面滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}；<br>","parent":"6d1881c50527","children":[]},{"id":"f8a8fffeb994","title":"scrollBy(x, y) 使得页面滚动特定的距离，支持传入配置型参数 {top, left}。<br>","parent":"6d1881c50527","children":[]},{"id":"e5f2da5e9ffb","title":"监听视口滚动事件，我们需要在 document 对象上绑定事件监听函数","parent":"6d1881c50527","children":[],"note":"```\ndocument.addEventListener(&quot;scroll&quot;, function(event){\n  //......\n})\n```"}]},{"id":"392178750169","title":"元素滚动 API","children":[{"id":"068525a616c8","title":"scrollTop 元素的属性，表示 Y 方向上的当前滚动距离。<br>","children":[],"parent":"392178750169"},{"id":"5c579b58891b","title":"scrollLeft 元素的属性，表示 X 方向上的当前滚动距离。<br>","children":[],"parent":"392178750169"},{"id":"8e5bb27d9d45","title":"scrollWidth 元素的属性，表示元素内部的滚动内容的宽度，一般来说会大于等于元素宽度。<br>","children":[],"parent":"392178750169"},{"id":"71e42a0c26bb","title":"scrollHeight 元素的属性，表示元素内部的滚动内容的高度，一般来说会大于等于元素高度。<br>","children":[],"parent":"392178750169"},{"id":"bb1d054c15b4","title":"scroll(x, y) 使得元素滚动到特定的位置，有别名 scrollTo，支持传入配置型参数 {top, left}。<br>","children":[],"parent":"392178750169"},{"id":"cab5dbd36a8c","title":"scrollBy(x, y) 使得元素滚动到特定的位置，支持传入配置型参数 {top, left}。<br>","children":[],"parent":"392178750169"},{"id":"bc6bda4143d1","title":"scrollIntoView(arg) 滚动元素所在的父元素，使得元素滚动到可见区域，可以通过 arg 来指定滚到中间、开始或者就近。","children":[],"parent":"392178750169"},{"id":"534bfd2ac062","title":"监听元素滚动事件，我们需要在 element 元素 对象上绑定事件监听函数","children":[],"parent":"392178750169","note":"```\nelement.addEventListener(&quot;scroll&quot;, function(event){\n  //......\n})\n```"}],"parent":"610269d5ca3f"}],"parent":"6377eac22de3"},{"id":"5bfb22a0990b","title":"布局 API","children":[{"id":"1977cd3ca013","title":"全局 API","children":[{"id":"75d52690ed63","title":"全局尺寸信息","children":[{"id":"fee03e8518de","title":"window.innerHeight, window.innerWidth 这两个属性表示视口的大小。","children":[],"parent":"75d52690ed63"},{"id":"967e8c7b4726","title":"window.outerWidth, window.outerHeight 这两个属性表示浏览器窗口占据的大小，很多浏览器没有实现，一般来说这两个属性无关紧要。","children":[],"parent":"75d52690ed63"},{"id":"0009b919b3a8","title":"window.devicePixelRatio 表示物理像素和 CSS 像素单位的倍率关系，Retina 屏这个值是 2，后来也出现了一些 3 倍的 Android 屏。","children":[],"parent":"75d52690ed63"},{"id":"4f1f82522ebe","title":"window.screen （屏幕尺寸相关的信息）","parent":"75d52690ed63","children":[{"id":"b48c5de5408f","title":"window.screen.width, window.screen.height 设备的屏幕尺寸。","parent":"4f1f82522ebe","children":[]},{"id":"a74fc5f0b253","title":"window.screen.availWidth, window.screen.availHeight 设备屏幕的可渲染区域尺寸，一些 Android 机器会把屏幕的一部分预留做固定按钮，所以有这两个属性，实际上一般浏览器不会实现的这么细致。","parent":"4f1f82522ebe","children":[]},{"id":"b20d5f990374","title":"window.screen.colorDepth, window.screen.pixelDepth 这两个属性是固定值 24，应该是为了以后预留。","parent":"4f1f82522ebe","children":[]}]}],"parent":"1977cd3ca013"}],"parent":"5bfb22a0990b"},{"id":"33cb3164b3cf","title":"元素 API","children":[{"id":"ce5611a90a76","title":"元素的布局信息","parent":"33cb3164b3cf","children":[{"id":"90e149b33d34","title":"getClientRects()","parent":"ce5611a90a76","children":[{"id":"66df46e14a28","title":"getClientRects 会返回一个列表，里面包含元素对应的每一个盒所占据的客户端矩形区域，这里每一个矩形区域可以用 x, y, width, height 来获取它的位置和尺寸。","children":[],"parent":"90e149b33d34"}]},{"id":"7d7ea5b4b1b2","title":"getBoundingClientRect()","parent":"ce5611a90a76","children":[{"id":"06a031c1f070","title":"getBoundingClientRect ，它返回元素对应的所有盒的包裹的矩形区域，需要注意，这个 API 获取的区域会包括当 overflow 为 visible 时的子元素区域。","children":[],"parent":"7d7ea5b4b1b2"}]}],"summaries":[{"summary":true,"id":"fdbe60d7442c","title":"这两个 API 获取的矩形区域都是相对于视口的坐标，这意味着，这些区域都是受滚动影响的。如果我们要获取相对坐标，或者包含滚动区域的坐标，需要一点小技巧：","range":0,"parent":"ce5611a90a76","children":[],"part":"right","note":"```\nvar offsetX = document.documentElement.getBoundingClientRect().x - element.getBoundingClientRect().x;\n```"}]}],"parent":"5bfb22a0990b"}],"parent":"6377eac22de3"}],"parent":"c3e686b715a3"}],"parent":"0e63b3038344","collapsed":true},{"id":"6932dcf8a87b","title":"事件","children":[],"parent":"0e63b3038344"},{"id":"731e992420cd","title":"API总集合","children":[],"parent":"0e63b3038344"}]},{"id":"48f3342dc865","title":"1、浏览器首先使用 HTTP 协议或者 HTTPS 协议，向服务端请求页面；","children":[{"id":"0d3a667d08b6","title":"HTTP协议（HTTP1.1：现行最流行版本）<br>","link":{"title":"HTTP 协议入门-ruanyf","value":"http://www.ruanyifeng.com/blog/2016/08/http.html","type":"url"},"parent":"48f3342dc865","children":[{"id":"21aaac8b96e8","title":"小实验：TCP 客户端来手工实现 HTTP","children":[{"id":"36a2f867dbc8","title":"请求部分 Request","children":[{"id":"af37ff284767","title":"请求行 request line","children":[{"id":"909f623c8a27","title":"请求方法 Method：表示此次 HTTP 请求希望执行的操作类型","children":[{"id":"a9e2f572e129","title":"GET","children":[{"id":"0ce154994e28","title":"浏览器通过地址栏访问页面都是 GET 方法。","children":[],"parent":"a9e2f572e129"}],"parent":"909f623c8a27"},{"id":"6ec638f0a12a","title":"POST","children":[{"id":"7115e1f8463f","title":"表单提交产生 POST 方法。","children":[],"parent":"6ec638f0a12a"}],"parent":"909f623c8a27"},{"id":"1f5daadbc502","title":"HEAD","children":[{"id":"cb0f6d491b5d","title":"HEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起","children":[],"parent":"1f5daadbc502"}],"parent":"909f623c8a27"},{"id":"6e262af9328e","title":"PUT/DELETE","children":[{"id":"8f7e9e3e5524","title":"PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。","children":[],"parent":"6e262af9328e"}],"parent":"909f623c8a27"},{"id":"4ef75129b463","title":"CONNECT","children":[{"id":"efa19e202188","title":"CONNECT 现在多用于 HTTPS 和 WebSocket。","children":[],"parent":"4ef75129b463"}],"parent":"909f623c8a27"},{"id":"3f8bee728992","title":"OPTIONS/TRACE<br>","children":[{"id":"3e905d8fdfc1","title":"OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。","children":[],"parent":"3f8bee728992"}],"parent":"909f623c8a27"}],"parent":"af37ff284767"},{"id":"d4c418a9aa7b","title":"请求路径 Path：请求的路径完全由服务端来定义","children":[],"parent":"af37ff284767"},{"id":"6a645c9e2c64","title":"请求协议：固定字符串（如HTTP/1.1）","children":[],"parent":"af37ff284767"}],"parent":"36a2f867dbc8","note":"```\nGET / HTTP/1.1\n```\n\n- 请求方法\n- 请求路径\n- 请求协议"},{"id":"e79dde28f536","title":"请求头 head","children":[{"id":"fe2755ab59c1","title":"HTTP 头可以看作一个键值对。","image":{"w":489,"url":"http://cdn.processon.com/5e5b31d0e4b0c037b6080f19?e=1583038432&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:CcimDiliwI-HFuZyDV6_b5e3hw4=","h":314},"children":[],"parent":"e79dde28f536"}],"parent":"36a2f867dbc8","collapsed":true},{"id":"42ef01c417cc","title":"请求体 body（一些常见的 body 格式是）","children":[{"id":"56f9faa7a872","title":"application/json","children":[],"parent":"42ef01c417cc"},{"id":"29d446d59aef","title":"application/x-www-form-urlencoded","children":[{"id":"0f1f35c882cc","title":"form 标签提交产生的 HTML 请求","children":[],"parent":"29d446d59aef"}],"parent":"42ef01c417cc"},{"id":"4493ef52d312","title":"multipart/form-data","children":[{"id":"b8dff2007cb8","title":"文件上传","children":[],"parent":"4493ef52d312"}],"parent":"42ef01c417cc"},{"id":"f389bc360d6b","title":"text/xml","children":[],"parent":"42ef01c417cc"}],"parent":"36a2f867dbc8"}],"parent":"21aaac8b96e8"},{"id":"60e79131c422","title":"响应部分 Response","children":[{"id":"9fe2d62bfc0e","title":"响应行 response line","children":[{"id":"b143276a39d7","title":"协议","children":[],"parent":"9fe2d62bfc0e"},{"id":"6a37af219a8d","title":"状态码","children":[{"id":"86b7924b4144","title":"1xx：临时回应，表示客户端请继续。（1xx 的状态会被浏览器 HTTP 库直接处理掉了，不会让上层应用知晓。）","children":[],"parent":"6a37af219a8d"},{"id":"eefe1295f6b2","title":"2xx","children":[{"id":"07326448a600","title":"200：请求成功。","children":[],"parent":"eefe1295f6b2"}],"parent":"6a37af219a8d"},{"id":"903a5c8f4114","title":"3xx：表示请求的目标有变化，希望客户端进一步处理。","children":[{"id":"227fac6428fa","title":"301：永久重定向（实际上 301 更接近于一种报错，提示客户端下次别来了）","children":[],"parent":"903a5c8f4114"},{"id":"f1a6e5c57df2","title":"302：临时重定向","children":[],"parent":"903a5c8f4114"},{"id":"a446b4a8d93a","title":"304：请求的服务端文件与本地缓存的文件相同","children":[],"parent":"903a5c8f4114"}],"parent":"6a37af219a8d"},{"id":"3bc519f60491","title":"4xx：客户端请求错误","children":[{"id":"5cfe121a5cbf","title":"403：无权限。<br>","children":[],"parent":"3bc519f60491"},{"id":"b19fb1474a42","title":"404：表示请求的页面不存在。","children":[],"parent":"3bc519f60491"},{"id":"d6ff8b7a0f0e","title":"418：It’s a teapot. 这是一个彩蛋，来自 ietf 的一个愚人节玩笑。","link":{"title":"","value":"https://tools.ietf.org/html/rfc2324","type":"url"},"children":[],"parent":"3bc519f60491"}],"parent":"6a37af219a8d"},{"id":"0ccae9bc972d","title":"5xx：服务端请求错误","children":[{"id":"a529063ce95c","title":"500：服务端错误。","children":[],"parent":"0ccae9bc972d"},{"id":"69f49624477e","title":"503：服务端暂时性错误，可以一会再试。","children":[],"parent":"0ccae9bc972d"}],"parent":"6a37af219a8d"}],"parent":"9fe2d62bfc0e"},{"id":"1d97e8bdf5cb","title":"状态文本","children":[],"parent":"9fe2d62bfc0e"}],"parent":"60e79131c422","note":"```\nHTTP/1.1 200 OK\n```\n\n- http协议\n- 状态码\n- 状态文本","collapsed":true},{"id":"e00b5dde3add","title":"响应头 head","children":[{"id":"a1c30c1ca6ff","title":"子主题","image":{"w":509,"url":"http://cdn.processon.com/5e5b31e2e4b0cb56dab11768?e=1583038450&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:2JBzNrgZ6F3czdm0GkOKKfNSjgU=","h":366},"children":[],"parent":"e00b5dde3add"}],"parent":"60e79131c422","collapsed":true},{"id":"06072244e608","title":"响应体 body","children":[],"parent":"60e79131c422"}],"parent":"21aaac8b96e8"}],"parent":"0d3a667d08b6"}],"note":"HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是`由浏览器端首先发起`的。\n\n&lt;br&gt;\n\nHTTP 是纯粹的`文本协议`，传输的都是文本内容。","collapsed":false},{"id":"d7f31c43e897","title":"HTTPS","children":[{"id":"5444311395d2","title":"一是确定请求的目标服务端身份","parent":"d7f31c43e897","children":[]},{"id":"1d71e2dbc06d","title":"二是保证传输的数据不会被网络中间节点窃听或者篡改。","parent":"d7f31c43e897","children":[]}],"parent":"48f3342dc865","note":"在 HTTP 协议的基础上，HTTPS 和 HTTP2 规定了更复杂的内容，但是它基本保持了 HTTP 的设计思想，即：使用上的 `Request-Response 模式`。\n\n&lt;br&gt;\n\nHTTPS 是使用加密通道来传输 HTTP 的内容。但是 HTTPS 首先与服务端建立一条 TLS 加密通道。TLS 构建于 TCP 协议之上，它实际上是对传输的内容做一次加密，所以从传输内容上看，HTTPS 跟 HTTP 没有任何区别。"},{"id":"cce082a5ed94","title":"HTTP 2","parent":"48f3342dc865","children":[{"id":"69477e57e749","title":"一是支持服务端推送","children":[],"parent":"cce082a5ed94","note":"服务端推送能够在客户端发送第一个请求到服务端时，提前把一部分内容推送给客户端，放入缓存当中，这可以避免客户端请求顺序带来的并行度不高，从而导致的性能问题。"},{"id":"65e08477c541","title":"二是支持 TCP 连接复用","children":[],"parent":"cce082a5ed94","note":"TCP 连接复用，则使用同一个 TCP 连接来传输多个 HTTP 请求，避免了 TCP 连接建立时的三次握手开销，和初建 TCP 连接时传输窗口小的问题。"}],"note":"HTTP 2 是 HTTP 1.1 的升级版本。\n\n"}],"parent":"root","collapsed":true},{"id":"3895712fc904","title":"2、把请求回来的 HTML 代码经过解析，构建成 DOM 树；","parent":"root","children":[{"id":"bc5859780198","title":"如何解析请求回来的HTML（响应体body）？","children":[{"id":"f4bdf65b4862","title":"词（token）的拆分","parent":"bc5859780198","children":[{"id":"7e1406473f65","title":"&lt;p class=\"a\"&gt;text text text&lt;/p&gt;","parent":"f4bdf65b4862","children":[{"id":"e50a211b165b","title":"&lt;p“标签开始”的开始；","parent":"7e1406473f65","children":[]},{"id":"6712cd9c92e9","title":"class=“a” 属性；","parent":"7e1406473f65","children":[]},{"id":"645c3893e314","title":"&gt;  “标签开始”的结束；","parent":"7e1406473f65","children":[]},{"id":"6fe3ac68cf9b","title":"text text text 文本；","parent":"7e1406473f65","children":[]},{"id":"947707ede6f0","title":"&lt;/p&gt; 标签结束。","parent":"7e1406473f65","children":[]}],"image":{"w":465,"url":"http://cdn.processon.com/5e5de3eee4b099155f940a2b?e=1583215103&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:yLgGjkXmvCPqpH2cYCdxCKqEBIg=","h":186}}]},{"id":"a0ad13d8c18f","title":"状态机","children":[],"parent":"bc5859780198","note":"状态机的初始状态，我们仅仅区分 “&lt; ”和 “非 &lt;”：\n\n- 如果获得的是一个非 &lt; 字符，那么可以认为进入了一个文本节点；\n- 如果获得的是一个 &lt; 字符，那么进入一个标签状态。\n\n不过当我们在标签状态时，则会面临着一些可能性。\n\n- 比如下一个字符是“ ! ” ，那么很可能是进入了注释节点或者 CDATA 节点。\n- 如果下一个字符是 “/ ”，那么可以确定进入了一个结束标签。\n- 如果下一个字符是字母，那么可以确定进入了一个开始标签。\n- 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。"},{"id":"77a13af54567","title":"如何用代码实现状态机？","children":[{"id":"d29db55fea5b","title":"这里的状态机，每一个状态是一个函数，通过“if else”来区分下一个字符做状态迁移。这里所谓的状态迁移，就是当前状态函数返回下一个状态函数。","children":[],"parent":"77a13af54567"}],"parent":"bc5859780198"}],"parent":"3895712fc904"},{"id":"ea68ce665cd8","title":"DOM树如何构建的？","children":[{"id":"39b7d8bb10e2","title":"通过“栈”构建<br>","children":[{"id":"3d4ee80c774d","title":"栈顶元素就是当前节点；","parent":"39b7d8bb10e2","children":[]},{"id":"76fa94949780","title":"遇到属性，就添加到当前节点；","parent":"39b7d8bb10e2","children":[]},{"id":"f34ddda7491d","title":"遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；","parent":"39b7d8bb10e2","children":[]},{"id":"6f1a75211a16","title":"遇到注释节点，作为当前节点的子节点；","parent":"39b7d8bb10e2","children":[]},{"id":"1c871237396a","title":"遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；","parent":"39b7d8bb10e2","children":[]},{"id":"db06fc2240b4","title":"遇到 tag end 就出栈一个节点（还可以检查是否匹配）。","parent":"39b7d8bb10e2","children":[]}],"parent":"ea68ce665cd8","note":"\n&lt;video src=&quot;blob:https://time.geekbang.org/4a29d336-e044-4b1b-a97c-a6761085084e&quot;&gt;&lt;/video&gt;"}],"parent":"3895712fc904"}],"collapsed":true},{"id":"9a6404644acb","title":"3、计算 DOM 树上的 CSS 属性；","parent":"root","children":[{"id":"b856bef19d22","title":"解析成CSS抽象语法树","parent":"9a6404644acb","children":[{"id":"acb824d51ad0","title":"后代选择器","parent":"b856bef19d22","children":[]},{"id":"2b09ca724c43","title":"~选择器","parent":"b856bef19d22","children":[]}]}]},{"id":"a8374c02d1b9","title":"4、最后根据 CSS 属性对元素逐个进行渲染，得到内存中的位图；","parent":"root","children":[],"note":""},{"id":"408b55b3a0fb","title":"5、合成之后，再绘制到界面上。（一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度；）","children":[{"id":"7d5390b2cee9","title":"渲染（把模型变成位图）","children":[{"id":"1d6df02a6ed7","title":"图形","parent":"7d5390b2cee9","children":[{"id":"5612918a46f7","title":"系统底层图形库支持+浏览器兼容不同平台","children":[],"parent":"1d6df02a6ed7"}],"note":"盒的背景，边框，SVG元素，阴影等"},{"id":"c762d08eea36","title":"文字","parent":"7d5390b2cee9","children":[{"id":"62bc4d6fce37","title":"底层字体库","parent":"c762d08eea36","children":[{"id":"93d3c8bfcaeb","title":"像素字形（小尺寸）","parent":"62bc4d6fce37","children":[]},{"id":"a8f28e3703b7","title":"矢量字形（大尺寸）","parent":"62bc4d6fce37","children":[{"id":"a309d09bec91","title":"FreeType字体库渲染","parent":"a8f28e3703b7","children":[]}]}]}]}],"parent":"408b55b3a0fb"},{"id":"1bef5f8f5e3a","title":"合成","parent":"408b55b3a0fb","children":[{"id":"3beb71d2f473","title":"最大限度减少绘制次数原则","children":[{"id":"82def55f74e5","title":"为哪些元素创建合成后的位图？","children":[],"parent":"3beb71d2f473"},{"id":"2f083b1539cd","title":"把哪些子元素渲染到合成的位图上面？","children":[],"parent":"3beb71d2f473"}],"parent":"1bef5f8f5e3a","note":"&gt; 好的合成策略是“猜测”可能变化的元素，把它排除到合成之外。\n\n目前，主流浏览器一般根据 position、transform 等属性来决定合成策略，来“猜测”这些元素未来可能发生变化。\n\n&lt;br&gt;\n\n但是，这样的猜测准确性有限，所以新的 CSS 标准中，规定了 `will-change` 属性，可以由业务代码来提示浏览器的合成策略，灵活运用这样的特性，可以大大提升合成策略的效果。"}],"note":"渲染的过程不会把子元素渲染到位图上，合成的过程就是为一些元素创建一个“合成后的位图”（我们称为合成层），把一部分子元素渲染到合成的位图上面。"},{"id":"deb778639cb7","title":"绘制","parent":"408b55b3a0fb","children":[],"note":"绘制是把`“位图最终绘制到屏幕上，变成肉眼可见的图像”`的过程，不过，一般来说，浏览器并不需要用代码来处理这个过程，浏览器只需要把最终要显示的位图交给操作系统即可。\n\n&lt;br&gt;\n\n这个过程听上去非常简单，这是因为在前面两个小节中，我们已经得到了每个元素的位图，并且对它们部分进行了合成，那么绘制过程，实际上就是按照 `z-index` 把它们依次绘制到屏幕上。"}],"parent":"root","note":""}],"lines":{},"note":"&gt; 这些步骤并非一个做完再做下一个，而是`不需要等到上一步骤完全结束，就开始处理上一步的输出`，类似流水线的工作方式。这样我们在浏览网页时，才会看到逐步出现的页面。\n\n"}},"meta":{"id":"5e61a2f1e4b09d2387944b8c","member":"5e488f9ee4b03d4e28b975b2","exportTime":"2020-03-19 10:56:40","diagramInfo":{"category":"mind_free","title":"5 浏览器工作原理","created":"2020-03-06 09:10:09","creator":"5e488f9ee4b03d4e28b975b2","modified":"2020-03-06 09:10:09"},"type":"ProcessOn Schema File","version":"1.0"}}