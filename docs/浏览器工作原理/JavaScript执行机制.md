## 执行上下文

理解了底层（执行上下文），上层的[变量提升](https://daotin.github.io/posts/2019/05/16/js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html)，作用域，闭包就理解了。

但，实际上，变量定义的位置并没有改变，而是因为经过了编译过程。

编译的时候，会把这些提升放到一个叫「变量环境」的地方。剩下的部分放在「可执行代码」部分。

执行代码的时候，缺什么就到变量环境去找。

主要是理解js代码是「**先编译，再执行**」的。

![](../assets/img-20240501210580.png)


执行上下文的范围分3种：

- 全局执行上下文
- 函数体执行上下文
- eval执行上下文

## 调用栈
> 调用栈就是用来管理函数调用关系的一种数据结构。

当有多个执行上下文的时候，通过栈（后进先出）的结构，进行管理和调用。

类似下面这样的结构，当函数执行完后，就会从栈顶弹出：

```js
var a = 2
function add(b,c){
  return b+c
}
function addAll(b,c){
	var d = 10
	result = add(b,c)
	return  a+result+d
}
addAll(3,6)
```

![](../assets/img-20240501210580-1.png)


## 块级作用域

由于变量提升，导致很多意料之外的结果，所以引入了let和const，也就有了块级作用域。

那么，let/const是如何影响执行上下文的？

```js
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

a,c会被提取到「变量环境」，但是let定义的变量不会，而是放到之前一直没提到的「词法环境」

而且，当执行到b=2的时候，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中。

![](../assets/img-20240501220511.png)

其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。

执行代码的时候，变量的查找，就从:沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。

![](../assets/img-20240501220586.png)

因此，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时**支持了变量提升和块级作用域**了。

## 作用域链

下面代码打印什么？是按照调用栈的顺序来查找变量的吗？然后打印“极客邦”？
```js
function bar() {
    console.log(myName)
}
function foo() {
    var myName = "极客邦"
    bar()
}
var myName = "极客时间"
foo()
```

![](../assets/img-20240501220563.png)


非也。打印的是“极客时间”。why？这就涉及到作用域链了。

其实，在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。

比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。

![](../assets/img-20240501220582.png)

可以看到是指向全局执行上下文的，为什么呢？

这里就涉及到词法作用域了，作用域链是由`词法作用域`决定的。

### 词法作用域

词法作用域就是指：作用域是由代码中**函数声明的位置**来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

静态的意思是：词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。







